{
  "source": {
    "LICENSE": {
      "path": "LICENSE",
      "mode": "100644",
      "content": "The MIT License (MIT)\n\nCopyright (c) 2014 \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
      "type": "blob"
    },
    "README.md": {
      "path": "README.md",
      "mode": "100644",
      "content": "haml-jr\n=======\n\nHaml reborn. Pure HTML5 templating.\n\nRight now this is in a transitional state.\n\nMigrating from: https://github.com/STRd6/haml-jr\n\nCurrently our web based env dosen't build the lexer so the compiled products\nare in /lib for now.\n",
      "type": "blob"
    },
    "TODO.md": {
      "path": "TODO.md",
      "mode": "100644",
      "content": "TODO\n====\n\nAdd all the sample hamls to the tests.\n\nGet the lexer and parser to build from the web.\n",
      "type": "blob"
    },
    "compiler.coffee": {
      "path": "compiler.coffee",
      "mode": "100644",
      "content": "# TODO: We should have this as a real dependency one day\n# CoffeeScript = require \"coffee-script\"\n\nindentText = (text, indent=\"  \") ->\n  indent + text.replace(/\\n/g, \"\\n#{indent}\")\n\nkeywords = [\n  \"on\"\n  \"each\"\n  \"with\"\n]\n\nkeywordsRegex = RegExp(\"^\\\\s*(#{keywords.join('|')})\\\\s+\")\n\nutil =\n  indent: indentText\n\n  filters:\n    verbatim: (content, compiler) ->\n      # TODO: Allow \"\"\" in content to stand\n      compiler.buffer '\"\"\"' + content.replace(/(#)/, \"\\\\$1\") + '\"\"\"'\n\n    plain: (content, compiler) ->\n      compiler.buffer JSON.stringify(content)\n\n    coffeescript: (content, compiler) ->\n      [content]\n\n    javascript: (content, compiler) ->\n      [\n        \"`\"\n        compiler.indent(content)\n        \"`\"\n      ]\n\n  element: (tag, contents=[]) ->\n    lines = [\n      \"__runtime.push document.createElement(#{JSON.stringify(tag)})\"\n      contents...\n      \"__runtime.pop()\"\n    ]\n\n  buffer: (value) ->\n    [\n      \"__runtime.text #{value}\"\n    ]\n\n  attributes: (node) ->\n    {id, classes, attributes} = node\n\n    if id\n      ids = [JSON.stringify(id)]\n    else\n      ids = []\n\n    classes = (classes || []).map JSON.stringify\n\n    if attributes\n      attributes = attributes.filter ({name, value}) ->\n        if name is \"class\"\n          classes.push value\n\n          false\n        else if name is \"id\"\n          ids.push value\n\n          false\n        else\n          true\n\n    else\n      attributes = []\n\n    idsAndClasses = []\n\n    if ids.length\n      idsAndClasses.push \"__runtime.id #{ids.join(', ')}\"\n\n    if classes.length\n      idsAndClasses.push \"__runtime.classes #{classes.join(', ')}\"\n\n    attributeLines = attributes.map ({name, value}) ->\n      name = JSON.stringify(name)\n\n      \"\"\"\n        __runtime.attribute #{name}, #{value}\n      \"\"\"\n\n    return idsAndClasses.concat attributeLines\n\n  render: (node) ->\n    {tag, filter, text} = node\n\n    if tag\n      @tag(node)\n    else if filter\n      @filter(node)\n    else\n      @contents(node)\n\n  replaceKeywords: (codeString) ->\n    codeString.replace(keywordsRegex, \"__runtime.$1 \")\n\n  filter: (node) ->\n    filterName = node.filter\n\n    if filter = @filters[filterName]\n      [].concat.apply([], @filters[filterName](node.content, this))\n    else\n      [\n        \"__runtime.filter(#{JSON.stringify(filterName)}, #{JSON.stringify(node.content)})\"\n      ]\n\n  contents: (node) ->\n    {children, bufferedCode, unbufferedCode, text} = node\n\n    if unbufferedCode\n      indent = true\n      code = @replaceKeywords(unbufferedCode)\n\n      contents = [code]\n    else if bufferedCode\n      contents = @buffer(bufferedCode)\n    else if text\n      contents = @buffer(JSON.stringify(text))\n    else if node.tag\n      contents = []\n    else if node.comment\n      # TODO: Create comment nodes\n      return []\n    else\n      contents = []\n      console.warn \"No content for node:\", node\n\n    if children\n      childContent = @renderNodes(children)\n\n      if indent\n        childContent = @indent(childContent.join(\"\\n\"))\n\n      contents = contents.concat(childContent)\n\n    return @attributes(node).concat contents\n\n  renderNodes: (nodes) ->\n    [].concat.apply([], nodes.map(@render, this))\n\n  tag: (node) ->\n    {tag} = node\n\n    @element tag, @contents(node)\n\nexports.compile = (parseTree, {compiler}={}) ->\n  compiler ?= CoffeeScript\n\n  items = util.renderNodes(parseTree)\n\n  source = \"\"\"\n    (data) ->\n      (->\n        __runtime = Runtime(this)\n\n        __runtime.push document.createDocumentFragment()\n    #{util.indent(items.join(\"\\n\"), \"    \")}\n        __runtime.pop()\n      ).call(data)\n  \"\"\"\n\n  options = bare: true\n  programSource = source\n\n  program = compiler.compile programSource, options\n\n  return program\n",
      "type": "blob"
    },
    "haml-jr.coffee": {
      "path": "haml-jr.coffee",
      "mode": "100644",
      "content": "{compile} = require \"./compiler\"\nlexer = require \"./lib/lexer\" # This is only in the build dir right now\n{parser} = require \"./lib/parser\"\n\nextend = (target, sources...) ->\n  for source in sources\n    for name of source\n      target[name] = source[name]\n\n  return target\n\noldParse = parser.parse\nextend parser,\n  lexer: lexer\n  parse: (input) ->\n    # Initialize shared state for gross hacks\n    extend parser.yy,\n      indent: 0\n      nodePath: [{children: []}]\n      filterIndent: undefined\n\n    return oldParse.call(parser, input)\n\nextend parser.yy,\n  extend: extend\n\n  newline: ->\n    lastNode = @nodePath[@nodePath.length - 1]\n\n    # TODO: Add newline nodes to tree to maintain\n    # spacing\n\n    if lastNode.filter\n      @appendFilterContent(lastNode, \"\")\n\n  append: (node, indentation=0) ->\n    if node.filterLine\n      lastNode = @nodePath[@nodePath.length - 1]\n      @appendFilterContent(lastNode, node.filterLine)\n\n      return\n\n    parent = @nodePath[indentation]\n    @appendChild parent, node\n\n    index = indentation + 1\n    @nodePath[index] = node\n    @nodePath.length = index + 1\n\n    return node\n\n  appendChild: (parent, child) ->\n    unless child.filter\n      @filterIndent = undefined\n      # Resetting back to initial state so we can handle\n      # back to back filters\n      @lexer.popState()\n\n    parent.children ||= []\n    parent.children.push child\n\n  appendFilterContent: (filter, content) ->\n    filter.content ||= \"\"\n    filter.content += \"#{content}\\n\"\n\nextend exports,\n  compile: (input, options) ->\n    if typeof input is \"string\"\n      input = parser.parse(input + \"\\n\")\n\n    return compile(input, options)\n  parser: parser\n",
      "type": "blob"
    },
    "lib/lexer.js": {
      "path": "lib/lexer.js",
      "mode": "100644",
      "content": "/* generated by jison-lex 0.2.1 */\nvar lexer = (function(){\nvar lexer = {\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {\"moduleName\":\"lexer\"},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:this.popState(); return 'NEWLINE';\nbreak;\ncase 1:yy_.yytext = yy_.yytext.trim(); return 'CODE';\nbreak;\ncase 2:this.popState(); return 'NEWLINE';\nbreak;\ncase 3:return 'TEXT';\nbreak;\ncase 4:this.popState(); return 'RIGHT_BRACE';\nbreak;\ncase 5:yy_.yytext = yy_.yytext.substring(1); return 'ATTRIBUTE';\nbreak;\ncase 6:this.begin('brace_value'); return 'EQUAL';\nbreak;\ncase 7:return 'SEPARATOR';\nbreak;\ncase 8:return 'TEXT';\nbreak;\ncase 9:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 10:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 11:return 'SEPARATOR';\nbreak;\ncase 12:this.popState(); return 'RIGHT_PARENTHESIS';\nbreak;\ncase 13:return 'ATTRIBUTE';\nbreak;\ncase 14:this.begin('value'); return 'EQUAL';\nbreak;\ncase 15:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 16:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 17:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 18:yy.indent = 0; this.popState(); return 'NEWLINE';\nbreak;\ncase 19:return 'EOF';\nbreak;\ncase 20:return 'FILTER_LINE';\nbreak;\ncase 21:yy.indent = 0; return 'NEWLINE';\nbreak;\ncase 22:return 'EOF';\nbreak;\ncase 23:return 'DOCTYPE';\nbreak;\ncase 24:yy.indent += 1; if(yy.indent > yy.filterIndent){this.begin('filter'); }; return 'INDENT';\nbreak;\ncase 25:this.begin(\"parentheses_attributes\"); return 'LEFT_PARENTHESIS';\nbreak;\ncase 26:this.begin(\"brace_attributes\"); return 'LEFT_BRACE';\nbreak;\ncase 27:yy_.yytext = yy_.yytext.substring(1); return 'COMMENT';\nbreak;\ncase 28:yy.filterIndent = yy.indent; yy_.yytext = yy_.yytext.substring(1); return 'FILTER';\nbreak;\ncase 29:yy_.yytext = yy_.yytext.substring(1); return 'ID';\nbreak;\ncase 30:yy_.yytext = yy_.yytext.substring(1); return 'CLASS';\nbreak;\ncase 31:yy_.yytext = yy_.yytext.substring(1); return 'TAG';\nbreak;\ncase 32:this.begin(\"code\"); return 'EQUAL';\nbreak;\ncase 33:this.begin(\"code\"); return 'HYPHEN';\nbreak;\ncase 34:return 'WHITESPACE';\nbreak;\ncase 35:return 'TEXT';\nbreak;\n}\n},\nrules: [/^(?:\\n)/,/^(?:.*)/,/^(?:\\n)/,/^(?:.*)/,/^(?:\\})/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:[ \\t]*=>[ \\t])/,/^(?:,[ \\t]*)/,/^(?:[^\\}]*)/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:[^ \\t\\}]*)/,/^(?:[ \\t]+)/,/^(?:\\))/,/^(?:([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:=)/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:'(\\\\.|[^\\\\'])*')/,/^(?:[^ \\t\\)]*)/,/^(?:\\n)/,/^(?:$)/,/^(?:[^\\n]*)/,/^(?:\\n)/,/^(?:$)/,/^(?:!!!)/,/^(?:  )/,/^(?:\\()/,/^(?:\\{)/,/^(?:\\/.*)/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:#((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:\\.((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:%((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:=)/,/^(?:-)/,/^(?:[ \\t]+)/,/^(?:.*)/],\nconditions: {\"filter\":{\"rules\":[18,19,20],\"inclusive\":false},\"value\":{\"rules\":[15,16,17],\"inclusive\":false},\"parentheses_attributes\":{\"rules\":[11,12,13,14],\"inclusive\":false},\"brace_value\":{\"rules\":[9,10],\"inclusive\":false},\"brace_attributes\":{\"rules\":[4,5,6,7,8],\"inclusive\":false},\"text\":{\"rules\":[2,3],\"inclusive\":false},\"code\":{\"rules\":[0,1],\"inclusive\":false},\"INITIAL\":{\"rules\":[21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],\"inclusive\":true}}\n};\nreturn lexer;\n})();\n\nmodule.exports = lexer;\n",
      "type": "blob"
    },
    "lib/parser.js": {
      "path": "lib/parser.js",
      "mode": "100644",
      "content": "/* parser generated by jison 0.4.10 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"root\":3,\"lines\":4,\"line\":5,\"indentation\":6,\"indentationLevel\":7,\"INDENT\":8,\"DOCTYPE\":9,\"end\":10,\"lineMain\":11,\"tag\":12,\"rest\":13,\"COMMENT\":14,\"FILTER\":15,\"FILTER_LINE\":16,\"NEWLINE\":17,\"EOF\":18,\"name\":19,\"tagComponents\":20,\"attributes\":21,\"idComponent\":22,\"classComponents\":23,\"ID\":24,\"CLASS\":25,\"LEFT_PARENTHESIS\":26,\"attributePairs\":27,\"RIGHT_PARENTHESIS\":28,\"LEFT_BRACE\":29,\"RIGHT_BRACE\":30,\"SEPARATOR\":31,\"attributePair\":32,\"ATTRIBUTE\":33,\"EQUAL\":34,\"ATTRIBUTE_VALUE\":35,\"TAG\":36,\"CODE\":37,\"HYPHEN\":38,\"text\":39,\"beginText\":40,\"TEXT\":41,\"WHITESPACE\":42,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",8:\"INDENT\",9:\"DOCTYPE\",14:\"COMMENT\",15:\"FILTER\",16:\"FILTER_LINE\",17:\"NEWLINE\",18:\"EOF\",24:\"ID\",25:\"CLASS\",26:\"LEFT_PARENTHESIS\",28:\"RIGHT_PARENTHESIS\",29:\"LEFT_BRACE\",30:\"RIGHT_BRACE\",31:\"SEPARATOR\",33:\"ATTRIBUTE\",34:\"EQUAL\",35:\"ATTRIBUTE_VALUE\",36:\"TAG\",37:\"CODE\",38:\"HYPHEN\",41:\"TEXT\",42:\"WHITESPACE\"},\nproductions_: [0,[3,1],[4,2],[4,1],[6,0],[6,1],[7,2],[7,1],[5,2],[5,3],[5,1],[11,2],[11,1],[11,1],[11,1],[11,1],[11,1],[10,1],[10,1],[12,2],[12,2],[12,1],[12,1],[20,3],[20,2],[20,2],[20,2],[20,1],[20,1],[22,1],[23,2],[23,1],[21,3],[21,3],[27,3],[27,1],[32,3],[19,1],[13,2],[13,2],[13,1],[39,2],[39,1],[40,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:return this.$ = yy.nodePath[0].children;\nbreak;\ncase 2:this.$ = $$[$0-1];\nbreak;\ncase 3:this.$ = $$[$0];\nbreak;\ncase 4:this.$ = 0;\nbreak;\ncase 5:this.$ = $$[$0];\nbreak;\ncase 6:this.$ = $$[$0-1] + 1;\nbreak;\ncase 7:this.$ = 1;\nbreak;\ncase 8:this.$ = \"doctype\";\nbreak;\ncase 9:this.$ = yy.append($$[$0-1], $$[$0-2]);\nbreak;\ncase 10:this.$ = (function () {\n        if ($$[$0].newline) {\n          return yy.newline();\n        }\n      }());\nbreak;\ncase 11:this.$ = yy.extend($$[$0-1], $$[$0]);\nbreak;\ncase 12:this.$ = $$[$0];\nbreak;\ncase 13:this.$ = $$[$0];\nbreak;\ncase 14:this.$ = {\n          comment: $$[$0]\n        };\nbreak;\ncase 15:this.$ = {\n          filter: $$[$0]\n        };\nbreak;\ncase 16:this.$ = {\n          filterLine: $$[$0]\n        };\nbreak;\ncase 17:this.$ = {\n          newline: true\n        };\nbreak;\ncase 18:this.$ = $$[$0];\nbreak;\ncase 19:this.$ = (function () {\n        $$[$0].tag = $$[$0-1];\n        return $$[$0];\n      }());\nbreak;\ncase 20:this.$ = {\n          tag: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 21:this.$ = {\n          tag: $$[$0]\n        };\nbreak;\ncase 22:this.$ = yy.extend($$[$0], {\n          tag: \"div\"\n        });\nbreak;\ncase 23:this.$ = {\n          id: $$[$0-2],\n          classes: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 24:this.$ = {\n          id: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 25:this.$ = {\n          classes: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 26:this.$ = {\n          id: $$[$0-1],\n          classes: $$[$0]\n        };\nbreak;\ncase 27:this.$ = {\n          id: $$[$0]\n        };\nbreak;\ncase 28:this.$ = {\n          classes: $$[$0]\n        };\nbreak;\ncase 29:this.$ = $$[$0];\nbreak;\ncase 30:this.$ = $$[$0-1].concat($$[$0]);\nbreak;\ncase 31:this.$ = [$$[$0]];\nbreak;\ncase 32:this.$ = $$[$0-1];\nbreak;\ncase 33:this.$ = $$[$0-1];\nbreak;\ncase 34:this.$ = $$[$0-2].concat($$[$0]);\nbreak;\ncase 35:this.$ = [$$[$0]];\nbreak;\ncase 36:this.$ = {\n          name: $$[$0-2],\n          value: $$[$0]\n        };\nbreak;\ncase 37:this.$ = $$[$0];\nbreak;\ncase 38:this.$ = {\n          bufferedCode: $$[$0]\n        };\nbreak;\ncase 39:this.$ = {\n          unbufferedCode: $$[$0]\n        };\nbreak;\ncase 40:this.$ = {\n          text: $$[$0] + \"\\n\"\n        };\nbreak;\ncase 41:this.$ = $$[$0];\nbreak;\ncase 42:this.$ = $$[$0];\nbreak;\ncase 43:this.$ = yy.lexer.begin('text');\nbreak;\n}\n},\ntable: [{3:1,4:2,5:3,6:5,7:7,8:[1,10],9:[1,4],10:6,14:[2,4],15:[2,4],16:[2,4],17:[1,8],18:[1,9],24:[2,4],25:[2,4],34:[2,4],36:[2,4],38:[2,4],41:[2,4],42:[2,4]},{1:[3]},{1:[2,1],5:11,6:5,7:7,8:[1,10],9:[1,4],10:6,14:[2,4],15:[2,4],16:[2,4],17:[1,8],18:[1,9],24:[2,4],25:[2,4],34:[2,4],36:[2,4],38:[2,4],41:[2,4],42:[2,4]},{1:[2,3],8:[2,3],9:[2,3],14:[2,3],15:[2,3],16:[2,3],17:[2,3],18:[2,3],24:[2,3],25:[2,3],34:[2,3],36:[2,3],38:[2,3],41:[2,3],42:[2,3]},{10:12,17:[1,8],18:[1,9]},{11:13,12:14,13:15,14:[1,16],15:[1,17],16:[1,18],19:19,20:20,22:25,23:26,24:[1,29],25:[1,30],34:[1,21],36:[1,24],38:[1,22],39:23,40:27,41:[1,28],42:[1,31]},{1:[2,10],8:[2,10],9:[2,10],14:[2,10],15:[2,10],16:[2,10],17:[2,10],18:[2,10],24:[2,10],25:[2,10],34:[2,10],36:[2,10],38:[2,10],41:[2,10],42:[2,10]},{8:[1,32],14:[2,5],15:[2,5],16:[2,5],24:[2,5],25:[2,5],34:[2,5],36:[2,5],38:[2,5],41:[2,5],42:[2,5]},{1:[2,17],8:[2,17],9:[2,17],14:[2,17],15:[2,17],16:[2,17],17:[2,17],18:[2,17],24:[2,17],25:[2,17],34:[2,17],36:[2,17],38:[2,17],41:[2,17],42:[2,17]},{1:[2,18],8:[2,18],9:[2,18],14:[2,18],15:[2,18],16:[2,18],17:[2,18],18:[2,18],24:[2,18],25:[2,18],34:[2,18],36:[2,18],38:[2,18],41:[2,18],42:[2,18]},{8:[2,7],14:[2,7],15:[2,7],16:[2,7],24:[2,7],25:[2,7],34:[2,7],36:[2,7],38:[2,7],41:[2,7],42:[2,7]},{1:[2,2],8:[2,2],9:[2,2],14:[2,2],15:[2,2],16:[2,2],17:[2,2],18:[2,2],24:[2,2],25:[2,2],34:[2,2],36:[2,2],38:[2,2],41:[2,2],42:[2,2]},{1:[2,8],8:[2,8],9:[2,8],14:[2,8],15:[2,8],16:[2,8],17:[2,8],18:[2,8],24:[2,8],25:[2,8],34:[2,8],36:[2,8],38:[2,8],41:[2,8],42:[2,8]},{10:33,17:[1,8],18:[1,9]},{13:34,17:[2,12],18:[2,12],34:[1,21],38:[1,22],39:23,40:27,41:[1,28],42:[1,31]},{17:[2,13],18:[2,13]},{17:[2,14],18:[2,14]},{17:[2,15],18:[2,15]},{17:[2,16],18:[2,16]},{17:[2,21],18:[2,21],20:35,21:36,22:25,23:26,24:[1,29],25:[1,30],26:[1,37],29:[1,38],34:[2,21],38:[2,21],41:[2,21],42:[2,21]},{17:[2,22],18:[2,22],34:[2,22],38:[2,22],41:[2,22],42:[2,22]},{37:[1,39]},{37:[1,40]},{17:[2,40],18:[2,40]},{17:[2,37],18:[2,37],24:[2,37],25:[2,37],26:[2,37],29:[2,37],34:[2,37],38:[2,37],41:[2,37],42:[2,37]},{17:[2,27],18:[2,27],21:42,23:41,25:[1,30],26:[1,37],29:[1,38],34:[2,27],38:[2,27],41:[2,27],42:[2,27]},{17:[2,28],18:[2,28],21:43,25:[1,44],26:[1,37],29:[1,38],34:[2,28],38:[2,28],41:[2,28],42:[2,28]},{41:[1,45]},{17:[2,42],18:[2,42]},{17:[2,29],18:[2,29],25:[2,29],26:[2,29],29:[2,29],34:[2,29],38:[2,29],41:[2,29],42:[2,29]},{17:[2,31],18:[2,31],25:[2,31],26:[2,31],29:[2,31],34:[2,31],38:[2,31],41:[2,31],42:[2,31]},{41:[2,43]},{8:[2,6],14:[2,6],15:[2,6],16:[2,6],24:[2,6],25:[2,6],34:[2,6],36:[2,6],38:[2,6],41:[2,6],42:[2,6]},{1:[2,9],8:[2,9],9:[2,9],14:[2,9],15:[2,9],16:[2,9],17:[2,9],18:[2,9],24:[2,9],25:[2,9],34:[2,9],36:[2,9],38:[2,9],41:[2,9],42:[2,9]},{17:[2,11],18:[2,11]},{17:[2,19],18:[2,19],34:[2,19],38:[2,19],41:[2,19],42:[2,19]},{17:[2,20],18:[2,20],34:[2,20],38:[2,20],41:[2,20],42:[2,20]},{27:46,32:47,33:[1,48]},{27:49,32:47,33:[1,48]},{17:[2,38],18:[2,38]},{17:[2,39],18:[2,39]},{17:[2,26],18:[2,26],21:50,25:[1,44],26:[1,37],29:[1,38],34:[2,26],38:[2,26],41:[2,26],42:[2,26]},{17:[2,24],18:[2,24],34:[2,24],38:[2,24],41:[2,24],42:[2,24]},{17:[2,25],18:[2,25],34:[2,25],38:[2,25],41:[2,25],42:[2,25]},{17:[2,30],18:[2,30],25:[2,30],26:[2,30],29:[2,30],34:[2,30],38:[2,30],41:[2,30],42:[2,30]},{17:[2,41],18:[2,41]},{28:[1,51],31:[1,52]},{28:[2,35],30:[2,35],31:[2,35]},{34:[1,53]},{30:[1,54],31:[1,52]},{17:[2,23],18:[2,23],34:[2,23],38:[2,23],41:[2,23],42:[2,23]},{17:[2,32],18:[2,32],34:[2,32],38:[2,32],41:[2,32],42:[2,32]},{32:55,33:[1,48]},{35:[1,56]},{17:[2,33],18:[2,33],34:[2,33],38:[2,33],41:[2,33],42:[2,33]},{28:[2,34],30:[2,34],31:[2,34]},{28:[2,36],30:[2,36],31:[2,36]}],\ndefaultActions: {31:[2,43]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        throw new Error(str);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    this.yy.parser = this;\n    if (typeof this.lexer.yylloc == 'undefined') {\n        this.lexer.yylloc = {};\n    }\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = this.lexer.options && this.lexer.options.ranges;\n    if (typeof this.yy.parseError === 'function') {\n        this.parseError = this.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    function lex() {\n        var token;\n        token = self.lexer.lex() || EOF;\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + this.lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: this.lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: this.lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(this.lexer.yytext);\n            lstack.push(this.lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\nundefined\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}\n",
      "type": "blob"
    },
    "runtime.coffee.md": {
      "path": "runtime.coffee.md",
      "mode": "100644",
      "content": "Runtime\n=======\n\nThis runtime component is all you need to render compiled HamlJr templates.\n\n    dataName = \"__hamlJR_data\"\n\n    if window?\n      document = window.document\n    else\n      document = global.document\n\n    Runtime = (context) ->\n      stack = []\n\n      # HAX: A document fragment is not your real dad\n      lastParent = ->\n        i = stack.length - 1\n        while (element = stack[i]) and element.nodeType is 11\n          i -= 1\n\n        element\n\n      top = ->\n        stack[stack.length-1]\n\n      append = (child) ->\n        top()?.appendChild(child)\n\n        return child\n\n      push = (child) ->\n        stack.push(child)\n\n      pop = ->\n        append(stack.pop())\n\n      render = (child) ->\n        push(child)\n        pop()\n\n      bindObservable = (element, value, update) ->\n        # CLI short-circuits here because it doesn't do observables\n        unless Observable?\n          update(value)\n          return\n\n        observable = Observable(value)\n        observable.observe update\n        update observable()\n\n        unobserve = ->\n          observable.stopObserving update\n\n        # Unsubscribe\n        element.addEventListener(\"DOMNodeRemoved\", unobserve, true)\n\n        return element\n\n      id = (sources...) ->\n        element = top()\n\n        update = (newValue) ->\n          # HACK: Working around CLI not having observables\n          if typeof newValue is \"function\"\n            newValue = newValue()\n\n          element.id = newValue\n\n        value = ->\n          possibleValues = sources.map (source) ->\n            if typeof source is \"function\"\n              source()\n            else\n              source\n          .filter (idValue) ->\n            idValue?\n\n          possibleValues[possibleValues.length-1]\n\n        bindObservable(element, value, update)\n\n      classes = (sources...) ->\n        element = top()\n\n        update = (newValue) ->\n          # HACK: Working around CLI not having observables\n          if typeof newValue is \"function\"\n            newValue = newValue()\n\n          element.className = newValue\n\n        value = ->\n          possibleValues = sources.map (source) ->\n            if typeof source is \"function\"\n              source()\n            else\n              source\n          .filter (sourceValue) ->\n            sourceValue?\n\n          possibleValues.join(\" \")\n\n        bindObservable(element, value, update)\n\n      observeAttribute = (name, value) ->\n        element = top()\n\n        update = (newValue) ->\n          element.setAttribute name, newValue\n\n        bindObservable(element, value, update)\n\n      observeText = (value) ->\n        # Kind of a hack for handling sub renders\n        # or adding explicit html nodes to the output\n        # TODO: May want to make more sure that it's a real dom node\n        #       and not some other object with a nodeType property\n        # TODO: This shouldn't be inside of the observeText method\n        switch value?.nodeType\n          when 1, 3, 11\n            render(value)\n            return\n\n        # HACK: We don't really want to know about the document inside here.\n        # Creating our text nodes in here cleans up the external call\n        # so it may be worth it.\n        element = document.createTextNode('')\n\n        update = (newValue) ->\n          element.nodeValue = newValue\n\n        bindObservable element, value, update\n\n        render element\n\n      return {\n        # Pushing and popping creates the node tree\n        push: push\n        pop: pop\n\n        id: id\n        classes: classes\n        attribute: observeAttribute\n        text: observeText\n\n        filter: (name, content) ->\n          ; # TODO self.filters[name](content)\n\n        each: (items, fn) ->\n          items = Observable(items)\n          elements = []\n          parent = lastParent()\n\n          # TODO: Work when rendering many sibling elements\n          items.observe (newItems) ->\n            replace elements, newItems\n\n          replace = (oldElements, items) ->\n            if oldElements\n              # TODO: There a lot of trouble if we can't find a parent\n              # We may be able to hack around it by observing when\n              # we're inserted into the dom and finding out what parent element\n              # we have\n              firstElement = oldElements[0]\n              parent = firstElement?.parentElement || parent\n\n              elements = items.map (item, index, array) ->\n                element = fn.call(item, item, index, array)\n                element[dataName] = item\n\n                parent.insertBefore element, firstElement\n\n                return element\n\n              oldElements.each (element) ->\n                element.remove()\n            else\n              elements = items.map (item, index, array) ->\n                element = fn.call(item, item, index, array)\n                element[dataName] = item\n\n                return element\n\n          replace(null, items)\n\n        with: (item, fn) ->\n          element = null\n\n          item = Observable(item)\n\n          item.observe (newValue) ->\n            replace element, newValue\n\n          value = item()\n\n          # TODO: Work when rendering many sibling elements\n          replace = (oldElement, value) ->\n            element = fn.call(value)\n            element[dataName] = item\n\n            if oldElement\n              parent = oldElement.parentElement\n              parent.insertBefore(element, oldElement)\n              oldElement.remove()\n            else\n              # Assume we got added?\n\n          replace(element, value)\n\n        on: (eventName, fn) ->\n          element = lastParent()\n\n          if eventName is \"change\"\n            switch element.nodeName\n              when \"SELECT\"\n                element[\"on#{eventName}\"] = ->\n                  selectedOption = @options[@selectedIndex]\n                  fn(selectedOption[dataName])\n\n                # Add bi-directionality if binding to an observable\n                if fn.observe\n                  fn.observe (newValue) ->\n                    Array::forEach.call(element.options, (option, index) ->\n                      element.selectedIndex = index if option[dataName] is newValue\n                    )\n              else\n                element[\"on#{eventName}\"] = ->\n                  fn(element.value)\n\n                if fn.observe\n                  fn.observe (newValue) ->\n                    element.value = newValue\n\n          else\n            element[\"on#{eventName}\"] = (event) ->\n              # TODO: Make sure this context is correct for nested\n              # things like `with` and `each`\n              fn.call(context, event)\n      }\n\n    module.exports = Runtime\n",
      "type": "blob"
    },
    "test/haml-jr.coffee": {
      "path": "test/haml-jr.coffee",
      "mode": "100644",
      "content": "{parser, compile} = HamlJr = require \"/haml-jr\"\n\nrun = (compiled, data) ->\n  Function(\"Runtime\", \"return \" + compiled)(require \"/runtime\")(data)\n\ndescribe 'HamlJr', ->\n  describe 'parser', ->\n    it 'should exist', ->\n      assert(parser)\n\n    it 'should parse some stuff', ->\n      assert parser.parse(\"%yolo\")\n\n  describe 'compiler', ->\n    describe 'keywords', ->\n      it \"should not replace `items.each` with `items.__each`\", ->\n        compiled = compile('- items.each ->')\n\n        assert !compiled.match(/items.__each/)\n\n      it \"should replace `on 'click'` with `__runtime.on 'click'`\", ->\n        compiled = compile('- on \"click\", ->')\n\n        assert compiled.match(/__runtime.on\\(\"click\"/)\n\n  describe \"runtime\", ->\n    it \"should not blow up on undefined text node values\", ->\n      compiled = compile('= @notThere')\n      assert run(compiled)\n\n  describe \"classes\", ->\n    it \"should render the classes passed in along with the classes prefixed\", ->\n      compiled = compile(\".radical(class=@myClass)\")\n\n      result = run compiled,\n        myClass: \"duder\"\n\n      assert.equal result.childNodes[0].className, \"radical duder\"\n\n    # TODO: Observable class attributes\n\n  describe \"ids\", ->\n    it \"should get them from the prefix\", ->\n      compiled = compile(\"#radical\")\n      result = run compiled\n\n      assert.equal result.childNodes[0].id, \"radical\"\n\n    it \"should be overridden by the attribute value if present\", ->\n      compiled = compile(\"#radical(id=@id)\")\n      result = run compiled,\n        id: \"wat\"\n\n      assert.equal result.childNodes[0].id, \"wat\"\n\n    it \"should not be overridden by the attribute value if not present\", ->\n      compiled = compile(\"#radical(id=@id)\")\n      result = run compiled\n\n      assert.equal result.childNodes[0].id, \"radical\"\n\n    # TODO: Observable id attributes\n\n  describe \"text\", ->\n    it \"should render text in nodes\", ->\n      compiled = compile(\"%div heyy\")\n      result = run compiled\n\n      assert.equal result.childNodes[0].textContent, \"heyy\\n\"\n",
      "type": "blob"
    },
    "pixie.cson": {
      "path": "pixie.cson",
      "mode": "100644",
      "content": "version: \"0.1.2\"\nentryPoint: \"haml-jr\"\nremoteDependencies: [\n  \"https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js\"\n]\n",
      "type": "blob"
    }
  },
  "distribution": {
    "compiler": {
      "path": "compiler",
      "content": "(function() {\n  var indentText, keywords, keywordsRegex, util,\n    __slice = [].slice;\n\n  indentText = function(text, indent) {\n    if (indent == null) {\n      indent = \"  \";\n    }\n    return indent + text.replace(/\\n/g, \"\\n\" + indent);\n  };\n\n  keywords = [\"on\", \"each\", \"with\"];\n\n  keywordsRegex = RegExp(\"^\\\\s*(\" + (keywords.join('|')) + \")\\\\s+\");\n\n  util = {\n    indent: indentText,\n    filters: {\n      verbatim: function(content, compiler) {\n        return compiler.buffer('\"\"\"' + content.replace(/(#)/, \"\\\\$1\") + '\"\"\"');\n      },\n      plain: function(content, compiler) {\n        return compiler.buffer(JSON.stringify(content));\n      },\n      coffeescript: function(content, compiler) {\n        return [content];\n      },\n      javascript: function(content, compiler) {\n        return [\"`\", compiler.indent(content), \"`\"];\n      }\n    },\n    element: function(tag, contents) {\n      var lines;\n      if (contents == null) {\n        contents = [];\n      }\n      return lines = [\"__runtime.push document.createElement(\" + (JSON.stringify(tag)) + \")\"].concat(__slice.call(contents), [\"__runtime.pop()\"]);\n    },\n    buffer: function(value) {\n      return [\"__runtime.text \" + value];\n    },\n    attributes: function(node) {\n      var attributeLines, attributes, classes, id, ids, idsAndClasses;\n      id = node.id, classes = node.classes, attributes = node.attributes;\n      if (id) {\n        ids = [JSON.stringify(id)];\n      } else {\n        ids = [];\n      }\n      classes = (classes || []).map(JSON.stringify);\n      if (attributes) {\n        attributes = attributes.filter(function(_arg) {\n          var name, value;\n          name = _arg.name, value = _arg.value;\n          if (name === \"class\") {\n            classes.push(value);\n            return false;\n          } else if (name === \"id\") {\n            ids.push(value);\n            return false;\n          } else {\n            return true;\n          }\n        });\n      } else {\n        attributes = [];\n      }\n      idsAndClasses = [];\n      if (ids.length) {\n        idsAndClasses.push(\"__runtime.id \" + (ids.join(', ')));\n      }\n      if (classes.length) {\n        idsAndClasses.push(\"__runtime.classes \" + (classes.join(', ')));\n      }\n      attributeLines = attributes.map(function(_arg) {\n        var name, value;\n        name = _arg.name, value = _arg.value;\n        name = JSON.stringify(name);\n        return \"__runtime.attribute \" + name + \", \" + value;\n      });\n      return idsAndClasses.concat(attributeLines);\n    },\n    render: function(node) {\n      var filter, tag, text;\n      tag = node.tag, filter = node.filter, text = node.text;\n      if (tag) {\n        return this.tag(node);\n      } else if (filter) {\n        return this.filter(node);\n      } else {\n        return this.contents(node);\n      }\n    },\n    replaceKeywords: function(codeString) {\n      return codeString.replace(keywordsRegex, \"__runtime.$1 \");\n    },\n    filter: function(node) {\n      var filter, filterName;\n      filterName = node.filter;\n      if (filter = this.filters[filterName]) {\n        return [].concat.apply([], this.filters[filterName](node.content, this));\n      } else {\n        return [\"__runtime.filter(\" + (JSON.stringify(filterName)) + \", \" + (JSON.stringify(node.content)) + \")\"];\n      }\n    },\n    contents: function(node) {\n      var bufferedCode, childContent, children, code, contents, indent, text, unbufferedCode;\n      children = node.children, bufferedCode = node.bufferedCode, unbufferedCode = node.unbufferedCode, text = node.text;\n      if (unbufferedCode) {\n        indent = true;\n        code = this.replaceKeywords(unbufferedCode);\n        contents = [code];\n      } else if (bufferedCode) {\n        contents = this.buffer(bufferedCode);\n      } else if (text) {\n        contents = this.buffer(JSON.stringify(text));\n      } else if (node.tag) {\n        contents = [];\n      } else if (node.comment) {\n        return [];\n      } else {\n        contents = [];\n        console.warn(\"No content for node:\", node);\n      }\n      if (children) {\n        childContent = this.renderNodes(children);\n        if (indent) {\n          childContent = this.indent(childContent.join(\"\\n\"));\n        }\n        contents = contents.concat(childContent);\n      }\n      return this.attributes(node).concat(contents);\n    },\n    renderNodes: function(nodes) {\n      return [].concat.apply([], nodes.map(this.render, this));\n    },\n    tag: function(node) {\n      var tag;\n      tag = node.tag;\n      return this.element(tag, this.contents(node));\n    }\n  };\n\n  exports.compile = function(parseTree, _arg) {\n    var compiler, items, options, program, programSource, source;\n    compiler = (_arg != null ? _arg : {}).compiler;\n    if (compiler == null) {\n      compiler = CoffeeScript;\n    }\n    items = util.renderNodes(parseTree);\n    source = \"(data) ->\\n  (->\\n    __runtime = Runtime(this)\\n\\n    __runtime.push document.createDocumentFragment()\\n\" + (util.indent(items.join(\"\\n\"), \"    \")) + \"\\n    __runtime.pop()\\n  ).call(data)\";\n    options = {\n      bare: true\n    };\n    programSource = source;\n    program = compiler.compile(programSource, options);\n    return program;\n  };\n\n}).call(this);\n\n//# sourceURL=compiler.coffee",
      "type": "blob"
    },
    "haml-jr": {
      "path": "haml-jr",
      "content": "(function() {\n  var compile, extend, lexer, oldParse, parser,\n    __slice = [].slice;\n\n  compile = require(\"./compiler\").compile;\n\n  lexer = require(\"./lib/lexer\");\n\n  parser = require(\"./lib/parser\").parser;\n\n  extend = function() {\n    var name, source, sources, target, _i, _len;\n    target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    for (_i = 0, _len = sources.length; _i < _len; _i++) {\n      source = sources[_i];\n      for (name in source) {\n        target[name] = source[name];\n      }\n    }\n    return target;\n  };\n\n  oldParse = parser.parse;\n\n  extend(parser, {\n    lexer: lexer,\n    parse: function(input) {\n      extend(parser.yy, {\n        indent: 0,\n        nodePath: [\n          {\n            children: []\n          }\n        ],\n        filterIndent: void 0\n      });\n      return oldParse.call(parser, input);\n    }\n  });\n\n  extend(parser.yy, {\n    extend: extend,\n    newline: function() {\n      var lastNode;\n      lastNode = this.nodePath[this.nodePath.length - 1];\n      if (lastNode.filter) {\n        return this.appendFilterContent(lastNode, \"\");\n      }\n    },\n    append: function(node, indentation) {\n      var index, lastNode, parent;\n      if (indentation == null) {\n        indentation = 0;\n      }\n      if (node.filterLine) {\n        lastNode = this.nodePath[this.nodePath.length - 1];\n        this.appendFilterContent(lastNode, node.filterLine);\n        return;\n      }\n      parent = this.nodePath[indentation];\n      this.appendChild(parent, node);\n      index = indentation + 1;\n      this.nodePath[index] = node;\n      this.nodePath.length = index + 1;\n      return node;\n    },\n    appendChild: function(parent, child) {\n      if (!child.filter) {\n        this.filterIndent = void 0;\n        this.lexer.popState();\n      }\n      parent.children || (parent.children = []);\n      return parent.children.push(child);\n    },\n    appendFilterContent: function(filter, content) {\n      filter.content || (filter.content = \"\");\n      return filter.content += \"\" + content + \"\\n\";\n    }\n  });\n\n  extend(exports, {\n    compile: function(input, options) {\n      if (typeof input === \"string\") {\n        input = parser.parse(input + \"\\n\");\n      }\n      return compile(input, options);\n    },\n    parser: parser\n  });\n\n}).call(this);\n\n//# sourceURL=haml-jr.coffee",
      "type": "blob"
    },
    "lib/lexer": {
      "path": "lib/lexer",
      "content": "/* generated by jison-lex 0.2.1 */\nvar lexer = (function(){\nvar lexer = {\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {\"moduleName\":\"lexer\"},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:this.popState(); return 'NEWLINE';\nbreak;\ncase 1:yy_.yytext = yy_.yytext.trim(); return 'CODE';\nbreak;\ncase 2:this.popState(); return 'NEWLINE';\nbreak;\ncase 3:return 'TEXT';\nbreak;\ncase 4:this.popState(); return 'RIGHT_BRACE';\nbreak;\ncase 5:yy_.yytext = yy_.yytext.substring(1); return 'ATTRIBUTE';\nbreak;\ncase 6:this.begin('brace_value'); return 'EQUAL';\nbreak;\ncase 7:return 'SEPARATOR';\nbreak;\ncase 8:return 'TEXT';\nbreak;\ncase 9:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 10:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 11:return 'SEPARATOR';\nbreak;\ncase 12:this.popState(); return 'RIGHT_PARENTHESIS';\nbreak;\ncase 13:return 'ATTRIBUTE';\nbreak;\ncase 14:this.begin('value'); return 'EQUAL';\nbreak;\ncase 15:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 16:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 17:this.popState(); return 'ATTRIBUTE_VALUE';\nbreak;\ncase 18:yy.indent = 0; this.popState(); return 'NEWLINE';\nbreak;\ncase 19:return 'EOF';\nbreak;\ncase 20:return 'FILTER_LINE';\nbreak;\ncase 21:yy.indent = 0; return 'NEWLINE';\nbreak;\ncase 22:return 'EOF';\nbreak;\ncase 23:return 'DOCTYPE';\nbreak;\ncase 24:yy.indent += 1; if(yy.indent > yy.filterIndent){this.begin('filter'); }; return 'INDENT';\nbreak;\ncase 25:this.begin(\"parentheses_attributes\"); return 'LEFT_PARENTHESIS';\nbreak;\ncase 26:this.begin(\"brace_attributes\"); return 'LEFT_BRACE';\nbreak;\ncase 27:yy_.yytext = yy_.yytext.substring(1); return 'COMMENT';\nbreak;\ncase 28:yy.filterIndent = yy.indent; yy_.yytext = yy_.yytext.substring(1); return 'FILTER';\nbreak;\ncase 29:yy_.yytext = yy_.yytext.substring(1); return 'ID';\nbreak;\ncase 30:yy_.yytext = yy_.yytext.substring(1); return 'CLASS';\nbreak;\ncase 31:yy_.yytext = yy_.yytext.substring(1); return 'TAG';\nbreak;\ncase 32:this.begin(\"code\"); return 'EQUAL';\nbreak;\ncase 33:this.begin(\"code\"); return 'HYPHEN';\nbreak;\ncase 34:return 'WHITESPACE';\nbreak;\ncase 35:return 'TEXT';\nbreak;\n}\n},\nrules: [/^(?:\\n)/,/^(?:.*)/,/^(?:\\n)/,/^(?:.*)/,/^(?:\\})/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:[ \\t]*=>[ \\t])/,/^(?:,[ \\t]*)/,/^(?:[^\\}]*)/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:[^ \\t\\}]*)/,/^(?:[ \\t]+)/,/^(?:\\))/,/^(?:([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:=)/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:'(\\\\.|[^\\\\'])*')/,/^(?:[^ \\t\\)]*)/,/^(?:\\n)/,/^(?:$)/,/^(?:[^\\n]*)/,/^(?:\\n)/,/^(?:$)/,/^(?:!!!)/,/^(?:  )/,/^(?:\\()/,/^(?:\\{)/,/^(?:\\/.*)/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:#((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:\\.((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:%((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:=)/,/^(?:-)/,/^(?:[ \\t]+)/,/^(?:.*)/],\nconditions: {\"filter\":{\"rules\":[18,19,20],\"inclusive\":false},\"value\":{\"rules\":[15,16,17],\"inclusive\":false},\"parentheses_attributes\":{\"rules\":[11,12,13,14],\"inclusive\":false},\"brace_value\":{\"rules\":[9,10],\"inclusive\":false},\"brace_attributes\":{\"rules\":[4,5,6,7,8],\"inclusive\":false},\"text\":{\"rules\":[2,3],\"inclusive\":false},\"code\":{\"rules\":[0,1],\"inclusive\":false},\"INITIAL\":{\"rules\":[21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],\"inclusive\":true}}\n};\nreturn lexer;\n})();\n\nmodule.exports = lexer;\n",
      "type": "blob"
    },
    "lib/parser": {
      "path": "lib/parser",
      "content": "/* parser generated by jison 0.4.10 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"root\":3,\"lines\":4,\"line\":5,\"indentation\":6,\"indentationLevel\":7,\"INDENT\":8,\"DOCTYPE\":9,\"end\":10,\"lineMain\":11,\"tag\":12,\"rest\":13,\"COMMENT\":14,\"FILTER\":15,\"FILTER_LINE\":16,\"NEWLINE\":17,\"EOF\":18,\"name\":19,\"tagComponents\":20,\"attributes\":21,\"idComponent\":22,\"classComponents\":23,\"ID\":24,\"CLASS\":25,\"LEFT_PARENTHESIS\":26,\"attributePairs\":27,\"RIGHT_PARENTHESIS\":28,\"LEFT_BRACE\":29,\"RIGHT_BRACE\":30,\"SEPARATOR\":31,\"attributePair\":32,\"ATTRIBUTE\":33,\"EQUAL\":34,\"ATTRIBUTE_VALUE\":35,\"TAG\":36,\"CODE\":37,\"HYPHEN\":38,\"text\":39,\"beginText\":40,\"TEXT\":41,\"WHITESPACE\":42,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",8:\"INDENT\",9:\"DOCTYPE\",14:\"COMMENT\",15:\"FILTER\",16:\"FILTER_LINE\",17:\"NEWLINE\",18:\"EOF\",24:\"ID\",25:\"CLASS\",26:\"LEFT_PARENTHESIS\",28:\"RIGHT_PARENTHESIS\",29:\"LEFT_BRACE\",30:\"RIGHT_BRACE\",31:\"SEPARATOR\",33:\"ATTRIBUTE\",34:\"EQUAL\",35:\"ATTRIBUTE_VALUE\",36:\"TAG\",37:\"CODE\",38:\"HYPHEN\",41:\"TEXT\",42:\"WHITESPACE\"},\nproductions_: [0,[3,1],[4,2],[4,1],[6,0],[6,1],[7,2],[7,1],[5,2],[5,3],[5,1],[11,2],[11,1],[11,1],[11,1],[11,1],[11,1],[10,1],[10,1],[12,2],[12,2],[12,1],[12,1],[20,3],[20,2],[20,2],[20,2],[20,1],[20,1],[22,1],[23,2],[23,1],[21,3],[21,3],[27,3],[27,1],[32,3],[19,1],[13,2],[13,2],[13,1],[39,2],[39,1],[40,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:return this.$ = yy.nodePath[0].children;\nbreak;\ncase 2:this.$ = $$[$0-1];\nbreak;\ncase 3:this.$ = $$[$0];\nbreak;\ncase 4:this.$ = 0;\nbreak;\ncase 5:this.$ = $$[$0];\nbreak;\ncase 6:this.$ = $$[$0-1] + 1;\nbreak;\ncase 7:this.$ = 1;\nbreak;\ncase 8:this.$ = \"doctype\";\nbreak;\ncase 9:this.$ = yy.append($$[$0-1], $$[$0-2]);\nbreak;\ncase 10:this.$ = (function () {\n        if ($$[$0].newline) {\n          return yy.newline();\n        }\n      }());\nbreak;\ncase 11:this.$ = yy.extend($$[$0-1], $$[$0]);\nbreak;\ncase 12:this.$ = $$[$0];\nbreak;\ncase 13:this.$ = $$[$0];\nbreak;\ncase 14:this.$ = {\n          comment: $$[$0]\n        };\nbreak;\ncase 15:this.$ = {\n          filter: $$[$0]\n        };\nbreak;\ncase 16:this.$ = {\n          filterLine: $$[$0]\n        };\nbreak;\ncase 17:this.$ = {\n          newline: true\n        };\nbreak;\ncase 18:this.$ = $$[$0];\nbreak;\ncase 19:this.$ = (function () {\n        $$[$0].tag = $$[$0-1];\n        return $$[$0];\n      }());\nbreak;\ncase 20:this.$ = {\n          tag: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 21:this.$ = {\n          tag: $$[$0]\n        };\nbreak;\ncase 22:this.$ = yy.extend($$[$0], {\n          tag: \"div\"\n        });\nbreak;\ncase 23:this.$ = {\n          id: $$[$0-2],\n          classes: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 24:this.$ = {\n          id: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 25:this.$ = {\n          classes: $$[$0-1],\n          attributes: $$[$0]\n        };\nbreak;\ncase 26:this.$ = {\n          id: $$[$0-1],\n          classes: $$[$0]\n        };\nbreak;\ncase 27:this.$ = {\n          id: $$[$0]\n        };\nbreak;\ncase 28:this.$ = {\n          classes: $$[$0]\n        };\nbreak;\ncase 29:this.$ = $$[$0];\nbreak;\ncase 30:this.$ = $$[$0-1].concat($$[$0]);\nbreak;\ncase 31:this.$ = [$$[$0]];\nbreak;\ncase 32:this.$ = $$[$0-1];\nbreak;\ncase 33:this.$ = $$[$0-1];\nbreak;\ncase 34:this.$ = $$[$0-2].concat($$[$0]);\nbreak;\ncase 35:this.$ = [$$[$0]];\nbreak;\ncase 36:this.$ = {\n          name: $$[$0-2],\n          value: $$[$0]\n        };\nbreak;\ncase 37:this.$ = $$[$0];\nbreak;\ncase 38:this.$ = {\n          bufferedCode: $$[$0]\n        };\nbreak;\ncase 39:this.$ = {\n          unbufferedCode: $$[$0]\n        };\nbreak;\ncase 40:this.$ = {\n          text: $$[$0] + \"\\n\"\n        };\nbreak;\ncase 41:this.$ = $$[$0];\nbreak;\ncase 42:this.$ = $$[$0];\nbreak;\ncase 43:this.$ = yy.lexer.begin('text');\nbreak;\n}\n},\ntable: [{3:1,4:2,5:3,6:5,7:7,8:[1,10],9:[1,4],10:6,14:[2,4],15:[2,4],16:[2,4],17:[1,8],18:[1,9],24:[2,4],25:[2,4],34:[2,4],36:[2,4],38:[2,4],41:[2,4],42:[2,4]},{1:[3]},{1:[2,1],5:11,6:5,7:7,8:[1,10],9:[1,4],10:6,14:[2,4],15:[2,4],16:[2,4],17:[1,8],18:[1,9],24:[2,4],25:[2,4],34:[2,4],36:[2,4],38:[2,4],41:[2,4],42:[2,4]},{1:[2,3],8:[2,3],9:[2,3],14:[2,3],15:[2,3],16:[2,3],17:[2,3],18:[2,3],24:[2,3],25:[2,3],34:[2,3],36:[2,3],38:[2,3],41:[2,3],42:[2,3]},{10:12,17:[1,8],18:[1,9]},{11:13,12:14,13:15,14:[1,16],15:[1,17],16:[1,18],19:19,20:20,22:25,23:26,24:[1,29],25:[1,30],34:[1,21],36:[1,24],38:[1,22],39:23,40:27,41:[1,28],42:[1,31]},{1:[2,10],8:[2,10],9:[2,10],14:[2,10],15:[2,10],16:[2,10],17:[2,10],18:[2,10],24:[2,10],25:[2,10],34:[2,10],36:[2,10],38:[2,10],41:[2,10],42:[2,10]},{8:[1,32],14:[2,5],15:[2,5],16:[2,5],24:[2,5],25:[2,5],34:[2,5],36:[2,5],38:[2,5],41:[2,5],42:[2,5]},{1:[2,17],8:[2,17],9:[2,17],14:[2,17],15:[2,17],16:[2,17],17:[2,17],18:[2,17],24:[2,17],25:[2,17],34:[2,17],36:[2,17],38:[2,17],41:[2,17],42:[2,17]},{1:[2,18],8:[2,18],9:[2,18],14:[2,18],15:[2,18],16:[2,18],17:[2,18],18:[2,18],24:[2,18],25:[2,18],34:[2,18],36:[2,18],38:[2,18],41:[2,18],42:[2,18]},{8:[2,7],14:[2,7],15:[2,7],16:[2,7],24:[2,7],25:[2,7],34:[2,7],36:[2,7],38:[2,7],41:[2,7],42:[2,7]},{1:[2,2],8:[2,2],9:[2,2],14:[2,2],15:[2,2],16:[2,2],17:[2,2],18:[2,2],24:[2,2],25:[2,2],34:[2,2],36:[2,2],38:[2,2],41:[2,2],42:[2,2]},{1:[2,8],8:[2,8],9:[2,8],14:[2,8],15:[2,8],16:[2,8],17:[2,8],18:[2,8],24:[2,8],25:[2,8],34:[2,8],36:[2,8],38:[2,8],41:[2,8],42:[2,8]},{10:33,17:[1,8],18:[1,9]},{13:34,17:[2,12],18:[2,12],34:[1,21],38:[1,22],39:23,40:27,41:[1,28],42:[1,31]},{17:[2,13],18:[2,13]},{17:[2,14],18:[2,14]},{17:[2,15],18:[2,15]},{17:[2,16],18:[2,16]},{17:[2,21],18:[2,21],20:35,21:36,22:25,23:26,24:[1,29],25:[1,30],26:[1,37],29:[1,38],34:[2,21],38:[2,21],41:[2,21],42:[2,21]},{17:[2,22],18:[2,22],34:[2,22],38:[2,22],41:[2,22],42:[2,22]},{37:[1,39]},{37:[1,40]},{17:[2,40],18:[2,40]},{17:[2,37],18:[2,37],24:[2,37],25:[2,37],26:[2,37],29:[2,37],34:[2,37],38:[2,37],41:[2,37],42:[2,37]},{17:[2,27],18:[2,27],21:42,23:41,25:[1,30],26:[1,37],29:[1,38],34:[2,27],38:[2,27],41:[2,27],42:[2,27]},{17:[2,28],18:[2,28],21:43,25:[1,44],26:[1,37],29:[1,38],34:[2,28],38:[2,28],41:[2,28],42:[2,28]},{41:[1,45]},{17:[2,42],18:[2,42]},{17:[2,29],18:[2,29],25:[2,29],26:[2,29],29:[2,29],34:[2,29],38:[2,29],41:[2,29],42:[2,29]},{17:[2,31],18:[2,31],25:[2,31],26:[2,31],29:[2,31],34:[2,31],38:[2,31],41:[2,31],42:[2,31]},{41:[2,43]},{8:[2,6],14:[2,6],15:[2,6],16:[2,6],24:[2,6],25:[2,6],34:[2,6],36:[2,6],38:[2,6],41:[2,6],42:[2,6]},{1:[2,9],8:[2,9],9:[2,9],14:[2,9],15:[2,9],16:[2,9],17:[2,9],18:[2,9],24:[2,9],25:[2,9],34:[2,9],36:[2,9],38:[2,9],41:[2,9],42:[2,9]},{17:[2,11],18:[2,11]},{17:[2,19],18:[2,19],34:[2,19],38:[2,19],41:[2,19],42:[2,19]},{17:[2,20],18:[2,20],34:[2,20],38:[2,20],41:[2,20],42:[2,20]},{27:46,32:47,33:[1,48]},{27:49,32:47,33:[1,48]},{17:[2,38],18:[2,38]},{17:[2,39],18:[2,39]},{17:[2,26],18:[2,26],21:50,25:[1,44],26:[1,37],29:[1,38],34:[2,26],38:[2,26],41:[2,26],42:[2,26]},{17:[2,24],18:[2,24],34:[2,24],38:[2,24],41:[2,24],42:[2,24]},{17:[2,25],18:[2,25],34:[2,25],38:[2,25],41:[2,25],42:[2,25]},{17:[2,30],18:[2,30],25:[2,30],26:[2,30],29:[2,30],34:[2,30],38:[2,30],41:[2,30],42:[2,30]},{17:[2,41],18:[2,41]},{28:[1,51],31:[1,52]},{28:[2,35],30:[2,35],31:[2,35]},{34:[1,53]},{30:[1,54],31:[1,52]},{17:[2,23],18:[2,23],34:[2,23],38:[2,23],41:[2,23],42:[2,23]},{17:[2,32],18:[2,32],34:[2,32],38:[2,32],41:[2,32],42:[2,32]},{32:55,33:[1,48]},{35:[1,56]},{17:[2,33],18:[2,33],34:[2,33],38:[2,33],41:[2,33],42:[2,33]},{28:[2,34],30:[2,34],31:[2,34]},{28:[2,36],30:[2,36],31:[2,36]}],\ndefaultActions: {31:[2,43]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        throw new Error(str);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    this.yy.parser = this;\n    if (typeof this.lexer.yylloc == 'undefined') {\n        this.lexer.yylloc = {};\n    }\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = this.lexer.options && this.lexer.options.ranges;\n    if (typeof this.yy.parseError === 'function') {\n        this.parseError = this.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    function lex() {\n        var token;\n        token = self.lexer.lex() || EOF;\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + this.lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: this.lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: this.lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(this.lexer.yytext);\n            lstack.push(this.lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\nundefined\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}\n",
      "type": "blob"
    },
    "runtime": {
      "path": "runtime",
      "content": "(function() {\n  var Runtime, dataName, document,\n    __slice = [].slice;\n\n  dataName = \"__hamlJR_data\";\n\n  if (typeof window !== \"undefined\" && window !== null) {\n    document = window.document;\n  } else {\n    document = global.document;\n  }\n\n  Runtime = function(context) {\n    var append, bindObservable, classes, id, lastParent, observeAttribute, observeText, pop, push, render, stack, top;\n    stack = [];\n    lastParent = function() {\n      var element, i;\n      i = stack.length - 1;\n      while ((element = stack[i]) && element.nodeType === 11) {\n        i -= 1;\n      }\n      return element;\n    };\n    top = function() {\n      return stack[stack.length - 1];\n    };\n    append = function(child) {\n      var _ref;\n      if ((_ref = top()) != null) {\n        _ref.appendChild(child);\n      }\n      return child;\n    };\n    push = function(child) {\n      return stack.push(child);\n    };\n    pop = function() {\n      return append(stack.pop());\n    };\n    render = function(child) {\n      push(child);\n      return pop();\n    };\n    bindObservable = function(element, value, update) {\n      var observable, unobserve;\n      if (typeof Observable === \"undefined\" || Observable === null) {\n        update(value);\n        return;\n      }\n      observable = Observable(value);\n      observable.observe(update);\n      update(observable());\n      unobserve = function() {\n        return observable.stopObserving(update);\n      };\n      element.addEventListener(\"DOMNodeRemoved\", unobserve, true);\n      return element;\n    };\n    id = function() {\n      var element, sources, update, value;\n      sources = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      element = top();\n      update = function(newValue) {\n        if (typeof newValue === \"function\") {\n          newValue = newValue();\n        }\n        return element.id = newValue;\n      };\n      value = function() {\n        var possibleValues;\n        possibleValues = sources.map(function(source) {\n          if (typeof source === \"function\") {\n            return source();\n          } else {\n            return source;\n          }\n        }).filter(function(idValue) {\n          return idValue != null;\n        });\n        return possibleValues[possibleValues.length - 1];\n      };\n      return bindObservable(element, value, update);\n    };\n    classes = function() {\n      var element, sources, update, value;\n      sources = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      element = top();\n      update = function(newValue) {\n        if (typeof newValue === \"function\") {\n          newValue = newValue();\n        }\n        return element.className = newValue;\n      };\n      value = function() {\n        var possibleValues;\n        possibleValues = sources.map(function(source) {\n          if (typeof source === \"function\") {\n            return source();\n          } else {\n            return source;\n          }\n        }).filter(function(sourceValue) {\n          return sourceValue != null;\n        });\n        return possibleValues.join(\" \");\n      };\n      return bindObservable(element, value, update);\n    };\n    observeAttribute = function(name, value) {\n      var element, update;\n      element = top();\n      update = function(newValue) {\n        return element.setAttribute(name, newValue);\n      };\n      return bindObservable(element, value, update);\n    };\n    observeText = function(value) {\n      var element, update;\n      switch (value != null ? value.nodeType : void 0) {\n        case 1:\n        case 3:\n        case 11:\n          render(value);\n          return;\n      }\n      element = document.createTextNode('');\n      update = function(newValue) {\n        return element.nodeValue = newValue;\n      };\n      bindObservable(element, value, update);\n      return render(element);\n    };\n    return {\n      push: push,\n      pop: pop,\n      id: id,\n      classes: classes,\n      attribute: observeAttribute,\n      text: observeText,\n      filter: function(name, content) {},\n      each: function(items, fn) {\n        var elements, parent, replace;\n        items = Observable(items);\n        elements = [];\n        parent = lastParent();\n        items.observe(function(newItems) {\n          return replace(elements, newItems);\n        });\n        replace = function(oldElements, items) {\n          var firstElement;\n          if (oldElements) {\n            firstElement = oldElements[0];\n            parent = (firstElement != null ? firstElement.parentElement : void 0) || parent;\n            elements = items.map(function(item, index, array) {\n              var element;\n              element = fn.call(item, item, index, array);\n              element[dataName] = item;\n              parent.insertBefore(element, firstElement);\n              return element;\n            });\n            return oldElements.each(function(element) {\n              return element.remove();\n            });\n          } else {\n            return elements = items.map(function(item, index, array) {\n              var element;\n              element = fn.call(item, item, index, array);\n              element[dataName] = item;\n              return element;\n            });\n          }\n        };\n        return replace(null, items);\n      },\n      \"with\": function(item, fn) {\n        var element, replace, value;\n        element = null;\n        item = Observable(item);\n        item.observe(function(newValue) {\n          return replace(element, newValue);\n        });\n        value = item();\n        replace = function(oldElement, value) {\n          var parent;\n          element = fn.call(value);\n          element[dataName] = item;\n          if (oldElement) {\n            parent = oldElement.parentElement;\n            parent.insertBefore(element, oldElement);\n            return oldElement.remove();\n          } else {\n\n          }\n        };\n        return replace(element, value);\n      },\n      on: function(eventName, fn) {\n        var element;\n        element = lastParent();\n        if (eventName === \"change\") {\n          switch (element.nodeName) {\n            case \"SELECT\":\n              element[\"on\" + eventName] = function() {\n                var selectedOption;\n                selectedOption = this.options[this.selectedIndex];\n                return fn(selectedOption[dataName]);\n              };\n              if (fn.observe) {\n                return fn.observe(function(newValue) {\n                  return Array.prototype.forEach.call(element.options, function(option, index) {\n                    if (option[dataName] === newValue) {\n                      return element.selectedIndex = index;\n                    }\n                  });\n                });\n              }\n              break;\n            default:\n              element[\"on\" + eventName] = function() {\n                return fn(element.value);\n              };\n              if (fn.observe) {\n                return fn.observe(function(newValue) {\n                  return element.value = newValue;\n                });\n              }\n          }\n        } else {\n          return element[\"on\" + eventName] = function(event) {\n            return fn.call(context, event);\n          };\n        }\n      }\n    };\n  };\n\n  module.exports = Runtime;\n\n}).call(this);\n\n//# sourceURL=runtime.coffee",
      "type": "blob"
    },
    "test/haml-jr": {
      "path": "test/haml-jr",
      "content": "(function() {\n  var HamlJr, compile, parser, run, _ref;\n\n  _ref = HamlJr = require(\"/haml-jr\"), parser = _ref.parser, compile = _ref.compile;\n\n  run = function(compiled, data) {\n    return Function(\"Runtime\", \"return \" + compiled)(require(\"/runtime\"))(data);\n  };\n\n  describe('HamlJr', function() {\n    describe('parser', function() {\n      it('should exist', function() {\n        return assert(parser);\n      });\n      return it('should parse some stuff', function() {\n        return assert(parser.parse(\"%yolo\"));\n      });\n    });\n    describe('compiler', function() {\n      return describe('keywords', function() {\n        it(\"should not replace `items.each` with `items.__each`\", function() {\n          var compiled;\n          compiled = compile('- items.each ->');\n          return assert(!compiled.match(/items.__each/));\n        });\n        return it(\"should replace `on 'click'` with `__runtime.on 'click'`\", function() {\n          var compiled;\n          compiled = compile('- on \"click\", ->');\n          return assert(compiled.match(/__runtime.on\\(\"click\"/));\n        });\n      });\n    });\n    describe(\"runtime\", function() {\n      return it(\"should not blow up on undefined text node values\", function() {\n        var compiled;\n        compiled = compile('= @notThere');\n        return assert(run(compiled));\n      });\n    });\n    describe(\"classes\", function() {\n      return it(\"should render the classes passed in along with the classes prefixed\", function() {\n        var compiled, result;\n        compiled = compile(\".radical(class=@myClass)\");\n        result = run(compiled, {\n          myClass: \"duder\"\n        });\n        return assert.equal(result.childNodes[0].className, \"radical duder\");\n      });\n    });\n    describe(\"ids\", function() {\n      it(\"should get them from the prefix\", function() {\n        var compiled, result;\n        compiled = compile(\"#radical\");\n        result = run(compiled);\n        return assert.equal(result.childNodes[0].id, \"radical\");\n      });\n      it(\"should be overridden by the attribute value if present\", function() {\n        var compiled, result;\n        compiled = compile(\"#radical(id=@id)\");\n        result = run(compiled, {\n          id: \"wat\"\n        });\n        return assert.equal(result.childNodes[0].id, \"wat\");\n      });\n      return it(\"should not be overridden by the attribute value if not present\", function() {\n        var compiled, result;\n        compiled = compile(\"#radical(id=@id)\");\n        result = run(compiled);\n        return assert.equal(result.childNodes[0].id, \"radical\");\n      });\n    });\n    return describe(\"text\", function() {\n      return it(\"should render text in nodes\", function() {\n        var compiled, result;\n        compiled = compile(\"%div heyy\");\n        result = run(compiled);\n        return assert.equal(result.childNodes[0].textContent, \"heyy\\n\");\n      });\n    });\n  });\n\n}).call(this);\n\n//# sourceURL=test/haml-jr.coffee",
      "type": "blob"
    },
    "pixie": {
      "path": "pixie",
      "content": "module.exports = {\"version\":\"0.1.2\",\"entryPoint\":\"haml-jr\",\"remoteDependencies\":[\"https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js\"]};",
      "type": "blob"
    }
  },
  "progenitor": {
    "url": "http://strd6.github.io/editor/"
  },
  "version": "0.1.2",
  "entryPoint": "haml-jr",
  "remoteDependencies": [
    "https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"
  ],
  "repository": {
    "id": 17689708,
    "name": "haml-jr",
    "full_name": "distri/haml-jr",
    "owner": {
      "login": "distri",
      "id": 6005125,
      "avatar_url": "https://gravatar.com/avatar/192f3f168409e79c42107f081139d9f3?d=https%3A%2F%2Fidenticons.github.com%2Ff90c81ffc1498e260c820082f2e7ca5f.png&r=x",
      "gravatar_id": "192f3f168409e79c42107f081139d9f3",
      "url": "https://api.github.com/users/distri",
      "html_url": "https://github.com/distri",
      "followers_url": "https://api.github.com/users/distri/followers",
      "following_url": "https://api.github.com/users/distri/following{/other_user}",
      "gists_url": "https://api.github.com/users/distri/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/distri/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/distri/subscriptions",
      "organizations_url": "https://api.github.com/users/distri/orgs",
      "repos_url": "https://api.github.com/users/distri/repos",
      "events_url": "https://api.github.com/users/distri/events{/privacy}",
      "received_events_url": "https://api.github.com/users/distri/received_events",
      "type": "Organization",
      "site_admin": false
    },
    "private": false,
    "html_url": "https://github.com/distri/haml-jr",
    "description": "Haml reborn. Pure HTML5 templating.",
    "fork": false,
    "url": "https://api.github.com/repos/distri/haml-jr",
    "forks_url": "https://api.github.com/repos/distri/haml-jr/forks",
    "keys_url": "https://api.github.com/repos/distri/haml-jr/keys{/key_id}",
    "collaborators_url": "https://api.github.com/repos/distri/haml-jr/collaborators{/collaborator}",
    "teams_url": "https://api.github.com/repos/distri/haml-jr/teams",
    "hooks_url": "https://api.github.com/repos/distri/haml-jr/hooks",
    "issue_events_url": "https://api.github.com/repos/distri/haml-jr/issues/events{/number}",
    "events_url": "https://api.github.com/repos/distri/haml-jr/events",
    "assignees_url": "https://api.github.com/repos/distri/haml-jr/assignees{/user}",
    "branches_url": "https://api.github.com/repos/distri/haml-jr/branches{/branch}",
    "tags_url": "https://api.github.com/repos/distri/haml-jr/tags",
    "blobs_url": "https://api.github.com/repos/distri/haml-jr/git/blobs{/sha}",
    "git_tags_url": "https://api.github.com/repos/distri/haml-jr/git/tags{/sha}",
    "git_refs_url": "https://api.github.com/repos/distri/haml-jr/git/refs{/sha}",
    "trees_url": "https://api.github.com/repos/distri/haml-jr/git/trees{/sha}",
    "statuses_url": "https://api.github.com/repos/distri/haml-jr/statuses/{sha}",
    "languages_url": "https://api.github.com/repos/distri/haml-jr/languages",
    "stargazers_url": "https://api.github.com/repos/distri/haml-jr/stargazers",
    "contributors_url": "https://api.github.com/repos/distri/haml-jr/contributors",
    "subscribers_url": "https://api.github.com/repos/distri/haml-jr/subscribers",
    "subscription_url": "https://api.github.com/repos/distri/haml-jr/subscription",
    "commits_url": "https://api.github.com/repos/distri/haml-jr/commits{/sha}",
    "git_commits_url": "https://api.github.com/repos/distri/haml-jr/git/commits{/sha}",
    "comments_url": "https://api.github.com/repos/distri/haml-jr/comments{/number}",
    "issue_comment_url": "https://api.github.com/repos/distri/haml-jr/issues/comments/{number}",
    "contents_url": "https://api.github.com/repos/distri/haml-jr/contents/{+path}",
    "compare_url": "https://api.github.com/repos/distri/haml-jr/compare/{base}...{head}",
    "merges_url": "https://api.github.com/repos/distri/haml-jr/merges",
    "archive_url": "https://api.github.com/repos/distri/haml-jr/{archive_format}{/ref}",
    "downloads_url": "https://api.github.com/repos/distri/haml-jr/downloads",
    "issues_url": "https://api.github.com/repos/distri/haml-jr/issues{/number}",
    "pulls_url": "https://api.github.com/repos/distri/haml-jr/pulls{/number}",
    "milestones_url": "https://api.github.com/repos/distri/haml-jr/milestones{/number}",
    "notifications_url": "https://api.github.com/repos/distri/haml-jr/notifications{?since,all,participating}",
    "labels_url": "https://api.github.com/repos/distri/haml-jr/labels{/name}",
    "releases_url": "https://api.github.com/repos/distri/haml-jr/releases{/id}",
    "created_at": "2014-03-13T00:54:54Z",
    "updated_at": "2014-03-13T02:08:39Z",
    "pushed_at": "2014-03-13T02:08:39Z",
    "git_url": "git://github.com/distri/haml-jr.git",
    "ssh_url": "git@github.com:distri/haml-jr.git",
    "clone_url": "https://github.com/distri/haml-jr.git",
    "svn_url": "https://github.com/distri/haml-jr",
    "homepage": null,
    "size": 0,
    "stargazers_count": 0,
    "watchers_count": 0,
    "language": "JavaScript",
    "has_issues": true,
    "has_downloads": true,
    "has_wiki": true,
    "forks_count": 0,
    "mirror_url": null,
    "open_issues_count": 0,
    "forks": 0,
    "open_issues": 0,
    "watchers": 0,
    "default_branch": "master",
    "master_branch": "master",
    "permissions": {
      "admin": true,
      "push": true,
      "pull": true
    },
    "organization": {
      "login": "distri",
      "id": 6005125,
      "avatar_url": "https://gravatar.com/avatar/192f3f168409e79c42107f081139d9f3?d=https%3A%2F%2Fidenticons.github.com%2Ff90c81ffc1498e260c820082f2e7ca5f.png&r=x",
      "gravatar_id": "192f3f168409e79c42107f081139d9f3",
      "url": "https://api.github.com/users/distri",
      "html_url": "https://github.com/distri",
      "followers_url": "https://api.github.com/users/distri/followers",
      "following_url": "https://api.github.com/users/distri/following{/other_user}",
      "gists_url": "https://api.github.com/users/distri/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/distri/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/distri/subscriptions",
      "organizations_url": "https://api.github.com/users/distri/orgs",
      "repos_url": "https://api.github.com/users/distri/repos",
      "events_url": "https://api.github.com/users/distri/events{/privacy}",
      "received_events_url": "https://api.github.com/users/distri/received_events",
      "type": "Organization",
      "site_admin": false
    },
    "network_count": 0,
    "subscribers_count": 2,
    "branch": "v0.1.2",
    "publishBranch": "gh-pages"
  },
  "dependencies": {}
}
