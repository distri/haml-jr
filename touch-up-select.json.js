window["distri/haml-jr:touch-up-select"]({
  "source": {
    "LICENSE": {
      "path": "LICENSE",
      "content": "The MIT License (MIT)\n\nCopyright (c) 2014 \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
      "mode": "100644",
      "type": "blob"
    },
    "README.md": {
      "path": "README.md",
      "content": "Haml Jr\n=======\n\nHaml reborn. Pure HTML5 templating.\n\nDemo: http://distri.github.io/haml-jr/docs/demo\n\nNotes\n-----\n\nCurrently our web based env dosen't build the lexer so the compiled products\nare in /lib for now.\n",
      "mode": "100644",
      "type": "blob"
    },
    "TODO.md": {
      "path": "TODO.md",
      "content": "TODO\n====\n\nFigure out the best way to have Observable included in the Runtime.\n\nAdd all the sample hamls to the tests.\n\nGet the lexer and parser to build from the web.\n",
      "mode": "100644",
      "type": "blob"
    },
    "compiler.coffee": {
      "path": "compiler.coffee",
      "content": "# TODO: We should have this as a real dependency one day\n# CoffeeScript = require \"coffee-script\"\n\nindentText = (text, indent=\"  \") ->\n  indent + text.replace(/\\n/g, \"\\n#{indent}\")\n\nkeywords = [\n  \"on\"\n  \"each\"\n  \"with\"\n]\n\nkeywordsRegex = RegExp(\"^\\\\s*(#{keywords.join('|')})\\\\s+\")\n\nutil =\n  indent: indentText\n\n  filters:\n    verbatim: (content, compiler) ->\n      # TODO: Allow \"\"\" in content to stand\n      compiler.buffer '\"\"\"' + content.replace(/(#)/, \"\\\\$1\") + '\"\"\"'\n\n    plain: (content, compiler) ->\n      compiler.buffer JSON.stringify(content)\n\n    coffeescript: (content, compiler) ->\n      [content]\n\n    javascript: (content, compiler) ->\n      [\n        \"`\"\n        compiler.indent(content)\n        \"`\"\n      ]\n\n  element: (tag, contents=[]) ->\n    lines = [\n      \"__runtime.push document.createElement(#{JSON.stringify(tag)})\"\n      contents...\n      \"__runtime.pop()\"\n    ]\n\n  buffer: (value) ->\n    [\n      \"__runtime.text #{value}\"\n    ]\n\n  attributes: (node) ->\n    {id, classes, attributes} = node\n\n    if id\n      ids = [JSON.stringify(id)]\n    else\n      ids = []\n\n    classes = (classes || []).map JSON.stringify\n\n    if attributes\n      attributes = attributes.filter ({name, value}) ->\n        if name is \"class\"\n          classes.push value\n\n          false\n        else if name is \"id\"\n          ids.push value\n\n          false\n        else\n          true\n\n    else\n      attributes = []\n\n    idsAndClasses = []\n\n    if ids.length\n      idsAndClasses.push \"__runtime.id #{ids.join(', ')}\"\n\n    if classes.length\n      idsAndClasses.push \"__runtime.classes #{classes.join(', ')}\"\n\n    attributeLines = attributes.map ({name, value}) ->\n      name = JSON.stringify(name)\n\n      \"\"\"\n        __runtime.attribute #{name}, #{value}\n      \"\"\"\n\n    return idsAndClasses.concat attributeLines\n\n  render: (node) ->\n    {tag, filter, text} = node\n\n    if tag\n      @tag(node)\n    else if filter\n      @filter(node)\n    else\n      @contents(node)\n\n  replaceKeywords: (codeString) ->\n    codeString.replace(keywordsRegex, \"__runtime.$1 \")\n\n  filter: (node) ->\n    filterName = node.filter\n\n    if filter = @filters[filterName]\n      [].concat.apply([], @filters[filterName](node.content, this))\n    else\n      [\n        \"__runtime.filter(#{JSON.stringify(filterName)}, #{JSON.stringify(node.content)})\"\n      ]\n\n  contents: (node) ->\n    {children, bufferedCode, unbufferedCode, text} = node\n\n    if unbufferedCode\n      indent = true\n      code = @replaceKeywords(unbufferedCode)\n\n      contents = [code]\n    else if bufferedCode\n      contents = @buffer(bufferedCode)\n    else if text\n      contents = @buffer(JSON.stringify(text))\n    else if node.tag\n      contents = []\n    else if node.comment\n      # TODO: Create comment nodes\n      return []\n    else\n      contents = []\n      console.warn \"No content for node:\", node\n\n    if children\n      childContent = @renderNodes(children)\n\n      if indent\n        childContent = @indent(childContent.join(\"\\n\"))\n\n      contents = contents.concat(childContent)\n\n    return @attributes(node).concat contents\n\n  renderNodes: (nodes) ->\n    [].concat.apply([], nodes.map(@render, this))\n\n  tag: (node) ->\n    {tag} = node\n\n    @element tag, @contents(node)\n\nexports.compile = (parseTree, {compiler}={}) ->\n  compiler ?= CoffeeScript\n\n  items = util.renderNodes(parseTree)\n\n  source = \"\"\"\n    (data) ->\n      (->\n        __runtime = Runtime(this)\n\n        __runtime.push document.createDocumentFragment()\n    #{util.indent(items.join(\"\\n\"), \"    \")}\n        __runtime.pop()\n      ).call(data)\n  \"\"\"\n\n  options = bare: true\n  programSource = source\n\n  program = compiler.compile programSource, options\n\n  return program\n",
      "mode": "100644",
      "type": "blob"
    },
    "demo.coffee.md": {
      "path": "demo.coffee.md",
      "content": "Hamlet Demo\n===========\n\nHamlet is a templating language for web applications. It's like React, Angular,\nor Knockout except not awful.\n\nSimple HTML\n-------\n\n>     #! demo\n>     template = \"\"\"\n>       %h1 Radical\n>       %hr\n>       %p Hello duder.\n>     \"\"\"\n\n---\n\nMultiple Bindings\n-----------------\n\n>     #! demo\n>     template = \"\"\"\n>       %input(type=\"text\" value=@value)\n>       %select(value=@value options=[1..@max])\n>       %hr\n>       %input(type=\"range\" value=@value min=\"1\" max=@max)\n>       %hr\n>       %progress(value=@value max=@max)\n>     \"\"\"\n>     model =\n>       max: 10\n>       value: Observable 5\n\n---\n\nInline Events\n-------------\n\n>     #! demo\n>     template = \"\"\"\n>       %button(click=@hello) Hello!\n>     \"\"\"\n>     model =\n>       hello: ->\n>         alert \"hello\"\n\n---\n\nDisabling Inputs\n----------------\n\n>     #! demo\n>     template = \"\"\"\n>       %button(disabled=@disabled click=@hello) A Button\n>       %button(click=@toggle) Toggle\n>     \"\"\"\n>     model =\n>       hello: ->\n>         alert \"hello\"\n>       disabled: Observable true\n>       toggle: ->\n>         model.disabled.toggle()\n>\n\n---\n\nTODO List\n---------\n\n>     #! demo\n>     template = \"\"\"\n>       %h2 TODO List\n>       %ul(style=\"list-style-type: none; padding: 0;\")\n>         - each @items, (item) ->\n>           %li\n>             %label\n>               %input(type=\"checkbox\")\n>               = item\n>       %form(submit=@add)\n>         %input(value=@name)\n>         %button Add Item\n>     \"\"\"\n>     model =\n>       name: Observable \"\"\n>       items: Observable []\n>       add: ->\n>         model.items.push model.name()\n>         model.name(\"\")\n>         return false\n\n\n---\n\nKnockout Demo\n-------------\n\n>     #! demo\n>     template = \"\"\"\n>       %select(value=@chosenTicket options=@tickets)\n>       %button(disabled=@disabled click=@reset) Clear\n>       .choice\n>         - each @chosenTicket, ->\n>           .ticket\n>             - if @price\n>               You have chosen!\n>               %b= @name\n>               = @price\n>     \"\"\"\n>     tickets = [\n>       {name: \"Choose...\", price: \"\"}\n>       {name: \"Economy\", price: 199.95}\n>       {name: \"Business\", price: 449.22}\n>       {name: \"First Class\", price: 1199.99}\n>     ]\n>     model =\n>       newTicket: ->\n>         tickets.push name: \"Yolo\", price: \"Free!\"\n>       tickets: tickets\n>       chosenTicket: Observable(tickets[0])\n>       reset: -> model.chosenTicket(tickets[0])\n>     model.disabled = Observable -> model.chosenTicket() is tickets[0]\n\n---\n\n\nDependent Functions\n-------------------\n\n>     #! demo\n>     template = \"\"\"\n>       %h2= @name\n>       %input(value=@first)\n>       %input(value=@last)\n>     \"\"\"\n>\n>     first = Observable(\"Mr.\")\n>     last = Observable(\"Doberman\")\n>\n>     model =\n>       name: ->\n>         first() + \" \" + last()\n>       first: first\n>       last: last\n\n---\n\nCheckbox\n--------\n\n>     #! demo\n>     template = \"\"\"\n>       %label\n>         %input(type=\"checkbox\" checked=@checked)\n>         = @checked\n>     \"\"\"\n>     model =\n>       checked: Observable true\n\n---\n\n\nInteractive Runtime\n-------------------\n\n>     #! setup\n>     require \"/interactive\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "haml-jr.coffee": {
      "path": "haml-jr.coffee",
      "content": "{compile} = require \"./compiler\"\n{lexer} = require \"./lib/lexer\"\n{parser} = require \"./lib/parser\"\n\nextend = (target, sources...) ->\n  for source in sources\n    for name of source\n      target[name] = source[name]\n\n  return target\n\noldParse = parser.parse\nextend parser,\n  lexer: lexer\n  parse: (input) ->\n    # Initialize shared state for gross hacks\n    extend parser.yy,\n      indent: 0\n      nodePath: [{children: []}]\n      filterIndent: undefined\n\n    return oldParse.call(parser, input)\n\nextend parser.yy,\n  extend: extend\n\n  newline: ->\n    lastNode = @nodePath[@nodePath.length - 1]\n\n    # TODO: Add newline nodes to tree to maintain\n    # spacing\n\n    if lastNode.filter\n      @appendFilterContent(lastNode, \"\")\n\n  append: (node, indentation=0) ->\n    if node.filterLine\n      lastNode = @nodePath[@nodePath.length - 1]\n      @appendFilterContent(lastNode, node.filterLine)\n\n      return\n\n    parent = @nodePath[indentation]\n    @appendChild parent, node\n\n    index = indentation + 1\n    @nodePath[index] = node\n    @nodePath.length = index + 1\n\n    return node\n\n  appendChild: (parent, child) ->\n    unless child.filter\n      @filterIndent = undefined\n      # Resetting back to initial state so we can handle\n      # back to back filters\n      @lexer.popState()\n\n    parent.children ||= []\n    parent.children.push child\n\n  appendFilterContent: (filter, content) ->\n    filter.content ||= \"\"\n    filter.content += \"#{content}\\n\"\n\nextend exports,\n  compile: (input, options) ->\n    if typeof input is \"string\"\n      input = parser.parse(input + \"\\n\")\n\n    return compile(input, options)\n  parser: parser\n",
      "mode": "100644",
      "type": "blob"
    },
    "interactive.coffee.md": {
      "path": "interactive.coffee.md",
      "content": "Interactive Runtime for Docs\n============================\n\n    HamlJr = require \"./haml-jr\"\n\n    # TODO: Update Runtime to not need global Observable\n    global.Observable = require \"observable\"\n    global.Runtime = require \"./runtime\"\n\n    # {applyStylesheet, CSON} = require \"./lib/util\"\n    # applyStylesheet require \"./style/demo\"\n\n    # TODO: Textarea for template, text area for data, live interactive demo\n    # Changing data reloads the new data into the same template\n    # Changing template reloads the same data into the new template\n\n    Interactive.register \"demo\", ({source, runtimeElement}) ->\n      code =\n        \"var template, model;\" +\n        CoffeeScript.compile(source, bare: true)\n\n      code += \"\\nreturn [template, model];\"\n\n      [template, model] = Function(\"Observable\", code)(Observable)\n\n      view = Function(\"return \" + HamlJr.compile(template))()\n\n      runtimeElement.empty().append view(model)\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/lexer.js": {
      "path": "lib/lexer.js",
      "content": "var lexer=function(){var lexer={EOF:1,parseError:function parseError(str,hash){if(this.yy.parser){this.yy.parser.parseError(str,hash)}else{throw new Error(str)}},setInput:function(input){this._input=input;this._more=this._backtrack=this.done=false;this.yylineno=this.yyleng=0;this.yytext=this.matched=this.match=\"\";this.conditionStack=[\"INITIAL\"];this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0};if(this.options.ranges){this.yylloc.range=[0,0]}this.offset=0;return this},input:function(){var ch=this._input[0];this.yytext+=ch;this.yyleng++;this.offset++;this.match+=ch;this.matched+=ch;var lines=ch.match(/(?:\\r\\n?|\\n).*/g);if(lines){this.yylineno++;this.yylloc.last_line++}else{this.yylloc.last_column++}if(this.options.ranges){this.yylloc.range[1]++}this._input=this._input.slice(1);return ch},unput:function(ch){var len=ch.length;var lines=ch.split(/(?:\\r\\n?|\\n)/g);this._input=ch+this._input;this.yytext=this.yytext.substr(0,this.yytext.length-len-1);this.offset-=len;var oldLines=this.match.split(/(?:\\r\\n?|\\n)/g);this.match=this.match.substr(0,this.match.length-1);this.matched=this.matched.substr(0,this.matched.length-1);if(lines.length-1){this.yylineno-=lines.length-1}var r=this.yylloc.range;this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:lines?(lines.length===oldLines.length?this.yylloc.first_column:0)+oldLines[oldLines.length-lines.length].length-lines[0].length:this.yylloc.first_column-len};if(this.options.ranges){this.yylloc.range=[r[0],r[0]+this.yyleng-len]}this.yyleng=this.yytext.length;return this},more:function(){this._more=true;return this},reject:function(){if(this.options.backtrack_lexer){this._backtrack=true}else{return this.parseError(\"Lexical error on line \"+(this.yylineno+1)+\". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\"+this.showPosition(),{text:\"\",token:null,line:this.yylineno})}return this},less:function(n){this.unput(this.match.slice(n))},pastInput:function(){var past=this.matched.substr(0,this.matched.length-this.match.length);return(past.length>20?\"...\":\"\")+past.substr(-20).replace(/\\n/g,\"\")},upcomingInput:function(){var next=this.match;if(next.length<20){next+=this._input.substr(0,20-next.length)}return(next.substr(0,20)+(next.length>20?\"...\":\"\")).replace(/\\n/g,\"\")},showPosition:function(){var pre=this.pastInput();var c=new Array(pre.length+1).join(\"-\");return pre+this.upcomingInput()+\"\\n\"+c+\"^\"},test_match:function(match,indexed_rule){var token,lines,backup;if(this.options.backtrack_lexer){backup={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done};if(this.options.ranges){backup.yylloc.range=this.yylloc.range.slice(0)}}lines=match[0].match(/(?:\\r\\n?|\\n).*/g);if(lines){this.yylineno+=lines.length}this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:lines?lines[lines.length-1].length-lines[lines.length-1].match(/\\r?\\n?/)[0].length:this.yylloc.last_column+match[0].length};this.yytext+=match[0];this.match+=match[0];this.matches=match;this.yyleng=this.yytext.length;if(this.options.ranges){this.yylloc.range=[this.offset,this.offset+=this.yyleng]}this._more=false;this._backtrack=false;this._input=this._input.slice(match[0].length);this.matched+=match[0];token=this.performAction.call(this,this.yy,this,indexed_rule,this.conditionStack[this.conditionStack.length-1]);if(this.done&&this._input){this.done=false}if(token){return token}else if(this._backtrack){for(var k in backup){this[k]=backup[k]}return false}return false},next:function(){if(this.done){return this.EOF}if(!this._input){this.done=true}var token,match,tempMatch,index;if(!this._more){this.yytext=\"\";this.match=\"\"}var rules=this._currentRules();for(var i=0;i<rules.length;i++){tempMatch=this._input.match(this.rules[rules[i]]);if(tempMatch&&(!match||tempMatch[0].length>match[0].length)){match=tempMatch;index=i;if(this.options.backtrack_lexer){token=this.test_match(tempMatch,rules[i]);if(token!==false){return token}else if(this._backtrack){match=false;continue}else{return false}}else if(!this.options.flex){break}}}if(match){token=this.test_match(match,rules[index]);if(token!==false){return token}return false}if(this._input===\"\"){return this.EOF}else{return this.parseError(\"Lexical error on line \"+(this.yylineno+1)+\". Unrecognized text.\\n\"+this.showPosition(),{text:\"\",token:null,line:this.yylineno})}},lex:function lex(){var r=this.next();if(r){return r}else{return this.lex()}},begin:function begin(condition){this.conditionStack.push(condition)},popState:function popState(){var n=this.conditionStack.length-1;if(n>0){return this.conditionStack.pop()}else{return this.conditionStack[0]}},_currentRules:function _currentRules(){if(this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]){return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules}else{return this.conditions[\"INITIAL\"].rules}},topState:function topState(n){n=this.conditionStack.length-1-Math.abs(n||0);if(n>=0){return this.conditionStack[n]}else{return\"INITIAL\"}},pushState:function pushState(condition){this.begin(condition)},stateStackSize:function stateStackSize(){return this.conditionStack.length},options:{moduleName:\"lexer\"},performAction:function anonymous(yy,yy_,$avoiding_name_collisions,YY_START){var YYSTATE=YY_START;switch($avoiding_name_collisions){case 0:this.popState();return\"RIGHT_BRACE\";break;case 1:yy_.yytext=yy_.yytext.substring(1);return\"ATTRIBUTE\";break;case 2:this.begin(\"brace_value\");return\"EQUAL\";break;case 3:return\"SEPARATOR\";break;case 4:return\"TEXT\";break;case 5:this.popState();return\"ATTRIBUTE_VALUE\";break;case 6:this.popState();return\"ATTRIBUTE_VALUE\";break;case 7:return\"SEPARATOR\";break;case 8:this.popState();return\"RIGHT_PARENTHESIS\";break;case 9:return\"ATTRIBUTE\";break;case 10:this.begin(\"value\");return\"EQUAL\";break;case 11:this.popState();return\"ATTRIBUTE_VALUE\";break;case 12:this.popState();return\"ATTRIBUTE_VALUE\";break;case 13:this.popState();return\"ATTRIBUTE_VALUE\";break;case 14:yy.indent=0;this.popState();return\"NEWLINE\";break;case 15:return\"FILTER_LINE\";break;case 16:yy.indent=0;return\"NEWLINE\";break;case 17:yy.indent+=1;if(yy.indent>yy.filterIndent){this.begin(\"filter\")};return\"INDENT\";break;case 18:this.begin(\"parentheses_attributes\");return\"LEFT_PARENTHESIS\";break;case 19:this.begin(\"brace_attributes\");return\"LEFT_BRACE\";break;case 20:yy_.yytext=yy_.yytext.substring(1);return\"COMMENT\";break;case 21:yy.filterIndent=yy.indent;yy_.yytext=yy_.yytext.substring(1);return\"FILTER\";break;case 22:yy_.yytext=yy_.yytext.substring(1);return\"ID\";break;case 23:yy_.yytext=yy_.yytext.substring(1);return\"CLASS\";break;case 24:yy_.yytext=yy_.yytext.substring(1);return\"TAG\";break;case 25:yy_.yytext=yy_.yytext.substring(1).trim();return\"BUFFERED_CODE\";break;case 26:yy_.yytext=yy_.yytext.substring(1).trim();return\"UNBUFFERED_CODE\";break;case 27:yy_.yytext=yy_.yytext.trimLeft();return\"TEXT\";break}},rules:[/^(?:\\})/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:[ \\t]*=>[ \\t])/,/^(?:,[ \\t]*)/,/^(?:[^\\}]*)/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:[^ \\t\\}]*)/,/^(?:[ \\t]+)/,/^(?:\\))/,/^(?:([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:=)/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:'(\\\\.|[^\\\\'])*')/,/^(?:[^ \\t\\)]*)/,/^(?:(\\n|$))/,/^(?:[^\\n]*)/,/^(?:\\s*(\\n|$))/,/^(?:  )/,/^(?:\\()/,/^(?:\\{)/,/^(?:\\/.*)/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:#((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:\\.((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:%((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:=.*)/,/^(?:-.*)/,/^(?:.*)/],conditions:{filter:{rules:[14,15],inclusive:false},value:{rules:[11,12,13],inclusive:false},parentheses_attributes:{rules:[7,8,9,10],inclusive:false},brace_value:{rules:[5,6],inclusive:false},brace_attributes:{rules:[0,1,2,3,4],inclusive:false},INITIAL:{rules:[16,17,18,19,20,21,22,23,24,25,26,27],inclusive:true}}};return lexer}();exports.lexer=lexer;",
      "mode": "100644",
      "type": "blob"
    },
    "lib/parser.js": {
      "path": "lib/parser.js",
      "content": "var parser=function(){var parser={trace:function trace(){},yy:{},symbols_:{error:2,root:3,lines:4,line:5,indentation:6,indentationLevel:7,INDENT:8,lineMain:9,end:10,tag:11,rest:12,COMMENT:13,FILTER:14,FILTER_LINE:15,NEWLINE:16,name:17,tagComponents:18,attributes:19,idComponent:20,classComponents:21,ID:22,CLASS:23,LEFT_PARENTHESIS:24,attributePairs:25,RIGHT_PARENTHESIS:26,LEFT_BRACE:27,RIGHT_BRACE:28,SEPARATOR:29,attributePair:30,ATTRIBUTE:31,EQUAL:32,ATTRIBUTE_VALUE:33,TAG:34,BUFFERED_CODE:35,UNBUFFERED_CODE:36,TEXT:37,$accept:0,$end:1},terminals_:{2:\"error\",8:\"INDENT\",13:\"COMMENT\",14:\"FILTER\",15:\"FILTER_LINE\",16:\"NEWLINE\",22:\"ID\",23:\"CLASS\",24:\"LEFT_PARENTHESIS\",26:\"RIGHT_PARENTHESIS\",27:\"LEFT_BRACE\",28:\"RIGHT_BRACE\",29:\"SEPARATOR\",31:\"ATTRIBUTE\",32:\"EQUAL\",33:\"ATTRIBUTE_VALUE\",34:\"TAG\",35:\"BUFFERED_CODE\",36:\"UNBUFFERED_CODE\",37:\"TEXT\"},productions_:[0,[3,1],[4,2],[4,1],[6,0],[6,1],[7,2],[7,1],[5,3],[5,1],[9,2],[9,1],[9,1],[9,1],[9,1],[9,1],[10,1],[11,2],[11,2],[11,1],[11,1],[18,3],[18,2],[18,2],[18,2],[18,1],[18,1],[20,1],[21,2],[21,1],[19,3],[19,3],[25,3],[25,1],[30,3],[17,1],[12,1],[12,1],[12,1]],performAction:function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$){var $0=$$.length-1;switch(yystate){case 1:return this.$=yy.nodePath[0].children;break;case 2:this.$=$$[$0-1];break;case 3:this.$=$$[$0];break;case 4:this.$=0;break;case 5:this.$=$$[$0];break;case 6:this.$=$$[$0-1]+1;break;case 7:this.$=1;break;case 8:this.$=yy.append($$[$0-1],$$[$0-2]);break;case 9:this.$=function(){if($$[$0].newline){return yy.newline()}}();break;case 10:this.$=yy.extend($$[$0-1],$$[$0]);break;case 11:this.$=$$[$0];break;case 12:this.$=$$[$0];break;case 13:this.$={comment:$$[$0]};break;case 14:this.$={filter:$$[$0]};break;case 15:this.$={filterLine:$$[$0]};break;case 16:this.$={newline:true};break;case 17:this.$=function(){$$[$0].tag=$$[$0-1];return $$[$0]}();break;case 18:this.$={tag:$$[$0-1],attributes:$$[$0]};break;case 19:this.$={tag:$$[$0]};break;case 20:this.$=yy.extend($$[$0],{tag:\"div\"});break;case 21:this.$={id:$$[$0-2],classes:$$[$0-1],attributes:$$[$0]};break;case 22:this.$={id:$$[$0-1],attributes:$$[$0]};break;case 23:this.$={classes:$$[$0-1],attributes:$$[$0]};break;case 24:this.$={id:$$[$0-1],classes:$$[$0]};break;case 25:this.$={id:$$[$0]};break;case 26:this.$={classes:$$[$0]};break;case 27:this.$=$$[$0];break;case 28:this.$=$$[$0-1].concat($$[$0]);break;case 29:this.$=[$$[$0]];break;case 30:this.$=$$[$0-1];break;case 31:this.$=$$[$0-1];break;case 32:this.$=$$[$0-2].concat($$[$0]);break;case 33:this.$=[$$[$0]];break;case 34:this.$={name:$$[$0-2],value:$$[$0]};break;case 35:this.$=$$[$0];break;case 36:this.$={bufferedCode:$$[$0]};break;case 37:this.$={unbufferedCode:$$[$0]};break;case 38:this.$={text:$$[$0]+\"\\n\"};break}},table:[{3:1,4:2,5:3,6:4,7:6,8:[1,8],10:5,13:[2,4],14:[2,4],15:[2,4],16:[1,7],22:[2,4],23:[2,4],34:[2,4],35:[2,4],36:[2,4],37:[2,4]},{1:[3]},{1:[2,1],5:9,6:4,7:6,8:[1,8],10:5,13:[2,4],14:[2,4],15:[2,4],16:[1,7],22:[2,4],23:[2,4],34:[2,4],35:[2,4],36:[2,4],37:[2,4]},{1:[2,3],8:[2,3],13:[2,3],14:[2,3],15:[2,3],16:[2,3],22:[2,3],23:[2,3],34:[2,3],35:[2,3],36:[2,3],37:[2,3]},{9:10,11:11,12:12,13:[1,13],14:[1,14],15:[1,15],17:16,18:17,20:22,21:23,22:[1,24],23:[1,25],34:[1,21],35:[1,18],36:[1,19],37:[1,20]},{1:[2,9],8:[2,9],13:[2,9],14:[2,9],15:[2,9],16:[2,9],22:[2,9],23:[2,9],34:[2,9],35:[2,9],36:[2,9],37:[2,9]},{8:[1,26],13:[2,5],14:[2,5],15:[2,5],22:[2,5],23:[2,5],34:[2,5],35:[2,5],36:[2,5],37:[2,5]},{1:[2,16],8:[2,16],13:[2,16],14:[2,16],15:[2,16],16:[2,16],22:[2,16],23:[2,16],34:[2,16],35:[2,16],36:[2,16],37:[2,16]},{8:[2,7],13:[2,7],14:[2,7],15:[2,7],22:[2,7],23:[2,7],34:[2,7],35:[2,7],36:[2,7],37:[2,7]},{1:[2,2],8:[2,2],13:[2,2],14:[2,2],15:[2,2],16:[2,2],22:[2,2],23:[2,2],34:[2,2],35:[2,2],36:[2,2],37:[2,2]},{10:27,16:[1,7]},{12:28,16:[2,11],35:[1,18],36:[1,19],37:[1,20]},{16:[2,12]},{16:[2,13]},{16:[2,14]},{16:[2,15]},{16:[2,19],18:29,19:30,20:22,21:23,22:[1,24],23:[1,25],24:[1,31],27:[1,32],35:[2,19],36:[2,19],37:[2,19]},{16:[2,20],35:[2,20],36:[2,20],37:[2,20]},{16:[2,36]},{16:[2,37]},{16:[2,38]},{16:[2,35],22:[2,35],23:[2,35],24:[2,35],27:[2,35],35:[2,35],36:[2,35],37:[2,35]},{16:[2,25],19:34,21:33,23:[1,25],24:[1,31],27:[1,32],35:[2,25],36:[2,25],37:[2,25]},{16:[2,26],19:35,23:[1,36],24:[1,31],27:[1,32],35:[2,26],36:[2,26],37:[2,26]},{16:[2,27],23:[2,27],24:[2,27],27:[2,27],35:[2,27],36:[2,27],37:[2,27]},{16:[2,29],23:[2,29],24:[2,29],27:[2,29],35:[2,29],36:[2,29],37:[2,29]},{8:[2,6],13:[2,6],14:[2,6],15:[2,6],22:[2,6],23:[2,6],34:[2,6],35:[2,6],36:[2,6],37:[2,6]},{1:[2,8],8:[2,8],13:[2,8],14:[2,8],15:[2,8],16:[2,8],22:[2,8],23:[2,8],34:[2,8],35:[2,8],36:[2,8],37:[2,8]},{16:[2,10]},{16:[2,17],35:[2,17],36:[2,17],37:[2,17]},{16:[2,18],35:[2,18],36:[2,18],37:[2,18]},{25:37,30:38,31:[1,39]},{25:40,30:38,31:[1,39]},{16:[2,24],19:41,23:[1,36],24:[1,31],27:[1,32],35:[2,24],36:[2,24],37:[2,24]},{16:[2,22],35:[2,22],36:[2,22],37:[2,22]},{16:[2,23],35:[2,23],36:[2,23],37:[2,23]},{16:[2,28],23:[2,28],24:[2,28],27:[2,28],35:[2,28],36:[2,28],37:[2,28]},{26:[1,42],29:[1,43]},{26:[2,33],28:[2,33],29:[2,33]},{32:[1,44]},{28:[1,45],29:[1,43]},{16:[2,21],35:[2,21],36:[2,21],37:[2,21]},{16:[2,30],35:[2,30],36:[2,30],37:[2,30]},{30:46,31:[1,39]},{33:[1,47]},{16:[2,31],35:[2,31],36:[2,31],37:[2,31]},{26:[2,32],28:[2,32],29:[2,32]},{26:[2,34],28:[2,34],29:[2,34]}],defaultActions:{12:[2,12],13:[2,13],14:[2,14],15:[2,15],18:[2,36],19:[2,37],20:[2,38],28:[2,10]},parseError:function parseError(str,hash){if(hash.recoverable){this.trace(str)}else{throw new Error(str)}},parse:function parse(input){var self=this,stack=[0],vstack=[null],lstack=[],table=this.table,yytext=\"\",yylineno=0,yyleng=0,recovering=0,TERROR=2,EOF=1;this.lexer.setInput(input);this.lexer.yy=this.yy;this.yy.lexer=this.lexer;this.yy.parser=this;if(typeof this.lexer.yylloc==\"undefined\"){this.lexer.yylloc={}}var yyloc=this.lexer.yylloc;lstack.push(yyloc);var ranges=this.lexer.options&&this.lexer.options.ranges;if(typeof this.yy.parseError===\"function\"){this.parseError=this.yy.parseError}else{this.parseError=Object.getPrototypeOf(this).parseError}function popStack(n){stack.length=stack.length-2*n;vstack.length=vstack.length-n;lstack.length=lstack.length-n}function lex(){var token;token=self.lexer.lex()||EOF;if(typeof token!==\"number\"){token=self.symbols_[token]||token}return token}var symbol,preErrorSymbol,state,action,a,r,yyval={},p,len,newState,expected;while(true){state=stack[stack.length-1];if(this.defaultActions[state]){action=this.defaultActions[state]}else{if(symbol===null||typeof symbol==\"undefined\"){symbol=lex()}action=table[state]&&table[state][symbol]}if(typeof action===\"undefined\"||!action.length||!action[0]){var errStr=\"\";expected=[];for(p in table[state]){if(this.terminals_[p]&&p>TERROR){expected.push(\"'\"+this.terminals_[p]+\"'\")}}if(this.lexer.showPosition){errStr=\"Parse error on line \"+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(\", \")+\", got '\"+(this.terminals_[symbol]||symbol)+\"'\"}else{errStr=\"Parse error on line \"+(yylineno+1)+\": Unexpected \"+(symbol==EOF?\"end of input\":\"'\"+(this.terminals_[symbol]||symbol)+\"'\")}this.parseError(errStr,{text:this.lexer.match,token:this.terminals_[symbol]||symbol,line:this.lexer.yylineno,loc:yyloc,expected:expected})}if(action[0]instanceof Array&&action.length>1){throw new Error(\"Parse Error: multiple actions possible at state: \"+state+\", token: \"+symbol)}switch(action[0]){case 1:stack.push(symbol);vstack.push(this.lexer.yytext);lstack.push(this.lexer.yylloc);stack.push(action[1]);symbol=null;if(!preErrorSymbol){yyleng=this.lexer.yyleng;yytext=this.lexer.yytext;yylineno=this.lexer.yylineno;yyloc=this.lexer.yylloc;if(recovering>0){recovering--}}else{symbol=preErrorSymbol;preErrorSymbol=null}break;case 2:len=this.productions_[action[1]][1];yyval.$=vstack[vstack.length-len];yyval._$={first_line:lstack[lstack.length-(len||1)].first_line,last_line:lstack[lstack.length-1].last_line,first_column:lstack[lstack.length-(len||1)].first_column,last_column:lstack[lstack.length-1].last_column};if(ranges){yyval._$.range=[lstack[lstack.length-(len||1)].range[0],lstack[lstack.length-1].range[1]]}r=this.performAction.call(yyval,yytext,yyleng,yylineno,this.yy,action[1],vstack,lstack);if(typeof r!==\"undefined\"){return r}if(len){stack=stack.slice(0,-1*len*2);vstack=vstack.slice(0,-1*len);lstack=lstack.slice(0,-1*len)}stack.push(this.productions_[action[1]][0]);vstack.push(yyval.$);lstack.push(yyval._$);newState=table[stack[stack.length-2]][stack[stack.length-1]];stack.push(newState);break;case 3:return true}}return true}};undefined;function Parser(){this.yy={}}Parser.prototype=parser;parser.Parser=Parser;return new Parser}();if(typeof require!==\"undefined\"&&typeof exports!==\"undefined\"){exports.parser=parser;exports.Parser=parser.Parser;exports.parse=function(){return parser.parse.apply(parser,arguments)};exports.main=function commonjsMain(args){if(!args[1]){console.log(\"Usage: \"+args[0]+\" FILE\");process.exit(1)}var source=require(\"fs\").readFileSync(require(\"path\").normalize(args[1]),\"utf8\");return exports.parser.parse(source)};if(typeof module!==\"undefined\"&&require.main===module){exports.main(process.argv.slice(1))}}",
      "mode": "100644",
      "type": "blob"
    },
    "lib/util.coffee.md": {
      "path": "lib/util.coffee.md",
      "content": "Util\n====\n\n    module.exports =\n      CSON:\n        parse: (source) ->\n          Function(\"return #{CoffeeScript.compile(source, bare: true)}\")()\n\n      applyStylesheet: (style, id=\"primary\") ->\n        styleNode = document.createElement(\"style\")\n        styleNode.innerHTML = style\n        styleNode.id = id\n\n        if previousStyleNode = document.head.querySelector(\"style##{id}\")\n          previousStyleNode.parentNode.removeChild(prevousStyleNode)\n\n        document.head.appendChild(styleNode)\n",
      "mode": "100644",
      "type": "blob"
    },
    "pixie.cson": {
      "path": "pixie.cson",
      "content": "version: \"0.2.2\"\nentryPoint: \"haml-jr\"\nremoteDependencies: [\n  \"https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js\"\n]\ndependencies:\n  observable: \"distri/observable:v0.1.2\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "runtime.coffee": {
      "path": "runtime.coffee",
      "content": "Observable = require \"observable\"\n\neventNames = \"\"\"\n  abort\n  blur\n  change\n  click\n  dblclick\n  drag\n  dragend\n  dragenter\n  dragleave\n  dragover\n  dragstart\n  drop\n  error\n  focus\n  input\n  keydown\n  keypress\n  keyup\n  load\n  mousedown\n  mousemove\n  mouseout\n  mouseover\n  mouseup\n  reset\n  resize\n  scroll\n  select\n  submit\n  touchcancel\n  touchend\n  touchenter\n  touchleave\n  touchmove\n  touchstart\n  unload\n\"\"\".split(\"\\n\")\n\nisEvent = (name) ->\n  eventNames.indexOf(name) != -1\n\nisFragment = (node) ->\n  node.nodeType is 11\n\nvalueBind = (element, value) ->\n  value = Observable value\n\n  switch element.nodeName\n    when \"SELECT\"\n      updateSelected = (newValue) ->\n        # This is so we can hold a non-string object as a value of the select element\n        element._value = newValue\n\n        if (options = element._options) and (typeof newValue is \"object\")\n          if newValue.value?\n            element.value = newValue.value\n          else\n            element.selectedIndex = options.indexOf(newValue)\n        else\n          element.value = newValue\n\n      # HACK: Need to set the value, but probably don't have the option contents yet\n      # so let's just do it after our execution suspends and we probably have them\n      setTimeout ->\n        updateSelected(value())\n      , 0\n\n      update = ->\n        {value:optionValue, _value} = @children[@selectedIndex]\n\n        value(_value or optionValue)\n\n      element.oninput = element.onchange = update\n      value.observe updateSelected\n    else\n      element.value = value()\n\n      # Because firing twice with the same value is idempotent just binding both\n      # oninput and onchange handles the widest range of inputs and browser\n      # inconsistencies.\n      element.oninput = ->\n        value(element.value)\n      element.onchange = ->\n        value(element.value)\n\n      value.observe (newValue) ->\n        element.value = newValue\n\n  return\n\nspecialBindings =\n  SELECT:\n    options: (element, values) ->\n      values = Observable values\n\n      updateValues = (values) ->\n        empty(element)\n        element._options = values\n\n        # TODO: Handle key: value... style options\n        # TODO: Should be able to leverage more of the runtime for binding observables here\n        values.map (value, index) ->\n          option = document.createElement(\"option\")\n          option._value = value\n          if typeof value is \"object\"\n            option.value = value?.value or index\n          else\n            option.value = value\n\n          option.textContent = value?.name or value\n\n          element.appendChild option\n          #TODO: Should select the value if it matches elemnent value\n          element.selectedIndex = index if value is element._value\n\n          return option\n\n      updateValues values()\n      values.observe updateValues\n\nRuntime = (context) ->\n  stack = []\n\n  # HAX: A document fragment is not your real dad\n  lastParent = ->\n    i = stack.length - 1\n    while (element = stack[i]) and isFragment(element)\n      i -= 1\n\n    element\n\n  top = ->\n    stack[stack.length-1]\n\n  append = (child) ->\n    parent = top()\n\n    # TODO: This seems a little gross\n    # The problem is that in each blocks our fragments are being emptied\n    # because they are appended to the parent before we return\n    # By appending and returning the child instead we should be able to\n    # keep a reference to the actual elements\n    if parent and isFragment(child) and child.childNodes.length is 1\n      child = child.childNodes[0]\n\n    top()?.appendChild(child)\n\n    return child\n\n  push = (child) ->\n    stack.push(child)\n\n  pop = ->\n    append(stack.pop())\n\n  render = (child) ->\n    push(child)\n    pop()\n\n  bindObservable = (element, value, update) ->\n    observable = Observable(value)\n    update observable()\n\n    observe = ->\n      observable.observe update\n      update observable()\n\n    unobserve = ->\n      observable.stopObserving update\n\n    element.addEventListener(\"DOMNodeInserted\", observe, true)\n    element.addEventListener(\"DOMNodeRemoved\", unobserve, true)\n\n    return element\n\n  id = (sources...) ->\n    element = top()\n\n    update = (newValue) ->\n      if typeof newValue is \"function\"\n        newValue = newValue()\n\n      element.id = newValue\n\n    value = ->\n      possibleValues = sources.map (source) ->\n        if typeof source is \"function\"\n          source()\n        else\n          source\n      .filter (idValue) ->\n        idValue?\n\n      possibleValues[possibleValues.length-1]\n\n    bindObservable(element, value, update)\n\n  classes = (sources...) ->\n    element = top()\n\n    update = (newValue) ->\n      if typeof newValue is \"function\"\n        newValue = newValue()\n\n      element.className = newValue\n\n    value = ->\n      possibleValues = sources.map (source) ->\n        if typeof source is \"function\"\n          source()\n        else\n          source\n      .filter (sourceValue) ->\n        sourceValue?\n\n      possibleValues.join(\" \")\n\n    bindObservable(element, value, update)\n\n  observeAttribute = (name, value) ->\n    element = top()\n\n    {nodeName} = element\n\n    update = (newValue) ->\n      if newValue? and newValue != false\n        element.setAttribute name, newValue\n      else\n        element.removeAttribute name\n\n    # TODO: Consolidate special bindings better than if/else\n    if (name is \"value\") and (typeof value is \"function\")\n      valueBind(element, value)\n    else if (name is \"checked\") and (typeof value is \"function\")\n      element.onchange = ->\n        value element.checked\n      bindObservable(element, value, update)\n    else if binding = specialBindings[nodeName]?[name]\n      binding(element, value)\n    # Straight up onclicks, etc.\n    else if name.match(/^on/) and isEvent(name.substr(2))\n      element[name] = value\n    # Handle click=@method\n    else if isEvent(name)\n      element[\"on#{name}\"] = value\n    else\n      bindObservable(element, value, update)\n\n    return element\n\n  observeText = (value) ->\n    # Kind of a hack for handling sub renders\n    # or adding explicit html nodes to the output\n    # TODO: May want to make more sure that it's a real dom node\n    #       and not some other object with a nodeType property\n    # TODO: This shouldn't be inside of the observeText method\n    switch value?.nodeType\n      when 1, 3, 11\n        return render(value)\n\n    # HACK: We don't really want to know about the document inside here.\n    # Creating our text nodes in here cleans up the external call\n    # so it may be worth it.\n    element = document.createTextNode('')\n\n    update = (newValue) ->\n      element.nodeValue = newValue\n\n    bindObservable element, value, update\n\n    render element\n\n  self =\n    # Pushing and popping creates the node tree\n    push: push\n    pop: pop\n\n    id: id\n    classes: classes\n    attribute: observeAttribute\n    text: observeText\n\n    filter: (name, content) ->\n      ; # TODO self.filters[name](content)\n\n    each: (items, fn) ->\n      items = Observable(items)\n      elements = null\n      parent = lastParent()\n\n      # TODO: Work when rendering many sibling elements\n      items.observe ->\n        replace elements\n\n      replace = (oldElements) ->\n        elements = []\n        items.each (item, index, array) ->\n          element = fn.call(item, item, index, array)\n\n          if isFragment(element)\n            elements.push element.childNodes...\n          else\n            elements.push element\n\n          parent.appendChild element\n\n          return element\n\n        oldElements?.forEach (element) ->\n          element.remove()\n\n      replace(null, items)\n\n  return self\n\nmodule.exports = Runtime\n\nempty = (node) ->\n  node.removeChild(child) while child = node.firstChild\n",
      "mode": "100644",
      "type": "blob"
    },
    "style/demo.styl": {
      "path": "style/demo.styl",
      "content": "#container \n  .sections \n    textarea\n      width: 50%\n",
      "mode": "100644",
      "type": "blob"
    },
    "test/haml-jr.coffee": {
      "path": "test/haml-jr.coffee",
      "content": "{parser, compile} = HamlJr = require \"/haml-jr\"\nRuntime = require \"/runtime\"\n\nglobal.Observable = require \"observable\"\n\nmakeTemplate = (code) ->\n  compiled = compile code\n  Function(\"Runtime\", \"return \" + compiled)(Runtime)\n\nrun = (code, data) ->\n  makeTemplate(code)(data)\n\ndescribe 'HamlJr', ->\n  describe 'parser', ->\n    it 'should exist', ->\n      assert(parser)\n\n    it 'should parse some stuff', ->\n      assert parser.parse(\"%yolo\")\n\n  describe 'compiler', ->\n    describe 'keywords', ->\n      it \"should not replace `items.each` with `items.__each`\", ->\n        compiled = compile('- items.each ->')\n\n        assert !compiled.match(/items.__each/)\n\n      it \"should replace `on 'click'` with `__runtime.on 'click'`\", ->\n        compiled = compile('- on \"click\", ->')\n\n        assert compiled.match(/__runtime.on\\(\"click\"/)\n\n  describe \"runtime\", ->\n    it \"should not blow up on undefined text node values\", ->\n      assert run('= @notThere')\n\n  describe \"classes\", ->\n    it \"should render the classes passed in along with the classes prefixed\", ->\n      result = run \".radical(class=@myClass)\",\n        myClass: \"duder\"\n\n      assert.equal result.childNodes[0].className, \"radical duder\"\n\n    # TODO: Observable class attributes\n\n  describe \"ids\", ->\n    it \"should get them from the prefix\", ->\n      result = run \"#radical\"\n\n      assert.equal result.childNodes[0].id, \"radical\"\n\n    it \"should be overridden by the attribute value if present\", ->\n      result = run \"#radical(id=@id)\",\n        id: \"wat\"\n\n      assert.equal result.childNodes[0].id, \"wat\"\n\n    it \"should not be overridden by the attribute value if not present\", ->\n      result = run \"#radical(id=@id)\"\n\n      assert.equal result.childNodes[0].id, \"radical\"\n\n    # TODO: Observable id attributes\n\n  describe \"text\", ->\n    it \"should render text in nodes\", ->\n      result = run \"%div heyy\"\n\n      assert.equal result.childNodes[0].textContent, \"heyy\\n\"\n\n  describe \"each\", ->\n    it \"should subrender\", ->\n      global.testTemplate = makeTemplate \".test= @\"\n      code = \"\"\"\n        %div\n          - each @, (item) ->\n            = testTemplate item\n      \"\"\"\n      result = run code, [0, 1, 2, 3]\n\n      assert.equal result.childNodes[0].childNodes[3].textContent, \"3\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "test/samples.coffee": {
      "path": "test/samples.coffee",
      "content": "{parser, compile} = HamlJr = require \"/haml-jr\"\n\nsamples =\n  attributes: \"\"\"\n    .yolo(id=@id class=\"cool cat\" data-test=\"test\" dude=@test)\n    #test.yolo2(class=@duder)\n  \"\"\"\n  browser: \"\"\"\n    %html\n      %head\n        %script(src=\"lib/cornerstone.js\")\n        %script(src=\"lib/coffee-script.js\")\n        %script(src=\"lib/jquery-1.10.2.min.js\")\n        %script(src=\"build/web.js\")\n      %body\n        %textarea\n          :verbatim\n            Choose a ticket class:\n            %select\n              - on \"change\", @chosenTicket\n              - each @tickets, ->\n                %option= @name\n\n            %button Clear\n              - on \"click\", @resetTicket\n\n            - with @chosenTicket, ->\n              %p\n                - if @price\n                  You have chosen\n                  %b= @name\n                  %span\n                    $#{@price}\n                - else\n                  No ticket chosen\n\n  \"\"\"\n  code_following_text: \"\"\"\n    Some Text\n    - a = \"wat\"\n  \"\"\"\n  complex: \"\"\"\n    %select\n      - radicalMessage = \"Yolo\"\n      - @tickets.forEach (ticket, i) ->\n        - if i is 0\n          = radicalMessage\n        %option\n          = ticket.name\n  \"\"\"\n  complex2: \"\"\"\n    !!!\n    %html\n      %head\n        %title Ravel | #{@name}'s photo tagged #{@tag}\n\n        - @props.each (key, value) ->\n          %meta(property=key content=value)\n\n        %link{:href => \"/images/favicon.ico\", :rel => \"icon\", :type => \"image/x-icon\"}\n\n        %link(rel=\"stylesheet\" href=\"/stylesheets/normalize.css\")\n        %link(rel=\"stylesheet\" href=\"/stylesheets/bootstrap.min.css\")\n        %link(rel=\"stylesheet\" href=\"/stylesheets/main.css\")\n\n        %script{:src => \"//use.typekit.net/ghp4eka.js\"}\n        :javascript\n          try{Typekit.load();}catch(e){}\n\n      %body\n        .facebook\n          %header\n            %h1.hide-text\n              Ravel\n          .content\n            .container\n              .individual\n                .user-container.clearfix\n                  .left\n                    .user-image\n                      %img{:src => @profile_picture_url}\n                    .user-info\n                      %span.name= @name\n                      %span.info= @gender_and_age\n                      %span.location.info= @location\n                      %span.tag= @tag\n                  .right\n                    %span.pins\n                      %img{:src => \"/images/pins@2x.png\"}\n                      = @pins\n                    %span.likes\n                      %img{:src => \"/images/likes@2x.png\"}\n                      = @likes\n                .photo-container\n                  %img{:src => @photo_url}\n              .download-button\n                %a.button.appstore{:href => \"http://itunes.apple.com/us/app/ravel!/id610859881?ls=1&mt=8\"}\n  \"\"\"\n  empty_lines: \"\"\"\n    %li\n\n      %ul\n\n        Yo\n\n\n\n\n\n  \"\"\"\n  filters: \"\"\"\n    :plain\n      cool\n      super cool\n        double super cool\n  \"\"\"\n  filters2: \"\"\"\n\n\n    :javascript\n      alert('yolo');\n\n    :coffeescript\n      alert \"yolo\"\n\n    .duder\n      col\n\n      :plain\n        sweets\n\n    .duder2\n      cool\n\n  \"\"\"\n  literal: \"\"\"\n    <literal>\n      <wat>\n      </wat>\n    </literal>\n    <yolo></yolo>\n  \"\"\"\n  simple: \"\"\"\n    %section#main.container\n      - post = title: \"cool\", subtitle: \"yolo\", content: \"radical\"\n      %h1= post.title\n      %h2= post.subtitle\n      .content\n        = post.content\n  \"\"\"\n  single_quotes: \"\"\"\n    %img(src='http://duderman.info/\\#{yolocountyusa}' data-rad='what the duder?')\n  \"\"\"\n  tickets: \"\"\"\n    Choose a ticket class:\n    %select\n      - on \"change\", @chosenTicket\n      - each @tickets, ->\n        %option= @name\n\n    %button Clear\n      - on \"click\", @resetTicket\n\n    - with @chosenTicket, ->\n      %p\n        - if @price\n          You have chosen\n          %b= @name\n          %span\n            $#{@price}\n        - else\n          No ticket chosen\n  \"\"\"\n\ndescribe \"Samples\", ->\n  Object.keys(samples).forEach (name) ->\n    data = samples[name]\n\n    it \"should parse '#{name}'\", ->\n      result = parser.parse(data)\n      console.log result\n      assert result\n\n    it \"should compile #{name}\", ->\n      result = compile(data)\n      console.log result\n      assert result\n",
      "mode": "100644",
      "type": "blob"
    }
  },
  "distribution": {
    "compiler": {
      "path": "compiler",
      "content": "(function() {\n  var indentText, keywords, keywordsRegex, util,\n    __slice = [].slice;\n\n  indentText = function(text, indent) {\n    if (indent == null) {\n      indent = \"  \";\n    }\n    return indent + text.replace(/\\n/g, \"\\n\" + indent);\n  };\n\n  keywords = [\"on\", \"each\", \"with\"];\n\n  keywordsRegex = RegExp(\"^\\\\s*(\" + (keywords.join('|')) + \")\\\\s+\");\n\n  util = {\n    indent: indentText,\n    filters: {\n      verbatim: function(content, compiler) {\n        return compiler.buffer('\"\"\"' + content.replace(/(#)/, \"\\\\$1\") + '\"\"\"');\n      },\n      plain: function(content, compiler) {\n        return compiler.buffer(JSON.stringify(content));\n      },\n      coffeescript: function(content, compiler) {\n        return [content];\n      },\n      javascript: function(content, compiler) {\n        return [\"`\", compiler.indent(content), \"`\"];\n      }\n    },\n    element: function(tag, contents) {\n      var lines;\n      if (contents == null) {\n        contents = [];\n      }\n      return lines = [\"__runtime.push document.createElement(\" + (JSON.stringify(tag)) + \")\"].concat(__slice.call(contents), [\"__runtime.pop()\"]);\n    },\n    buffer: function(value) {\n      return [\"__runtime.text \" + value];\n    },\n    attributes: function(node) {\n      var attributeLines, attributes, classes, id, ids, idsAndClasses;\n      id = node.id, classes = node.classes, attributes = node.attributes;\n      if (id) {\n        ids = [JSON.stringify(id)];\n      } else {\n        ids = [];\n      }\n      classes = (classes || []).map(JSON.stringify);\n      if (attributes) {\n        attributes = attributes.filter(function(_arg) {\n          var name, value;\n          name = _arg.name, value = _arg.value;\n          if (name === \"class\") {\n            classes.push(value);\n            return false;\n          } else if (name === \"id\") {\n            ids.push(value);\n            return false;\n          } else {\n            return true;\n          }\n        });\n      } else {\n        attributes = [];\n      }\n      idsAndClasses = [];\n      if (ids.length) {\n        idsAndClasses.push(\"__runtime.id \" + (ids.join(', ')));\n      }\n      if (classes.length) {\n        idsAndClasses.push(\"__runtime.classes \" + (classes.join(', ')));\n      }\n      attributeLines = attributes.map(function(_arg) {\n        var name, value;\n        name = _arg.name, value = _arg.value;\n        name = JSON.stringify(name);\n        return \"__runtime.attribute \" + name + \", \" + value;\n      });\n      return idsAndClasses.concat(attributeLines);\n    },\n    render: function(node) {\n      var filter, tag, text;\n      tag = node.tag, filter = node.filter, text = node.text;\n      if (tag) {\n        return this.tag(node);\n      } else if (filter) {\n        return this.filter(node);\n      } else {\n        return this.contents(node);\n      }\n    },\n    replaceKeywords: function(codeString) {\n      return codeString.replace(keywordsRegex, \"__runtime.$1 \");\n    },\n    filter: function(node) {\n      var filter, filterName;\n      filterName = node.filter;\n      if (filter = this.filters[filterName]) {\n        return [].concat.apply([], this.filters[filterName](node.content, this));\n      } else {\n        return [\"__runtime.filter(\" + (JSON.stringify(filterName)) + \", \" + (JSON.stringify(node.content)) + \")\"];\n      }\n    },\n    contents: function(node) {\n      var bufferedCode, childContent, children, code, contents, indent, text, unbufferedCode;\n      children = node.children, bufferedCode = node.bufferedCode, unbufferedCode = node.unbufferedCode, text = node.text;\n      if (unbufferedCode) {\n        indent = true;\n        code = this.replaceKeywords(unbufferedCode);\n        contents = [code];\n      } else if (bufferedCode) {\n        contents = this.buffer(bufferedCode);\n      } else if (text) {\n        contents = this.buffer(JSON.stringify(text));\n      } else if (node.tag) {\n        contents = [];\n      } else if (node.comment) {\n        return [];\n      } else {\n        contents = [];\n        console.warn(\"No content for node:\", node);\n      }\n      if (children) {\n        childContent = this.renderNodes(children);\n        if (indent) {\n          childContent = this.indent(childContent.join(\"\\n\"));\n        }\n        contents = contents.concat(childContent);\n      }\n      return this.attributes(node).concat(contents);\n    },\n    renderNodes: function(nodes) {\n      return [].concat.apply([], nodes.map(this.render, this));\n    },\n    tag: function(node) {\n      var tag;\n      tag = node.tag;\n      return this.element(tag, this.contents(node));\n    }\n  };\n\n  exports.compile = function(parseTree, _arg) {\n    var compiler, items, options, program, programSource, source;\n    compiler = (_arg != null ? _arg : {}).compiler;\n    if (compiler == null) {\n      compiler = CoffeeScript;\n    }\n    items = util.renderNodes(parseTree);\n    source = \"(data) ->\\n  (->\\n    __runtime = Runtime(this)\\n\\n    __runtime.push document.createDocumentFragment()\\n\" + (util.indent(items.join(\"\\n\"), \"    \")) + \"\\n    __runtime.pop()\\n  ).call(data)\";\n    options = {\n      bare: true\n    };\n    programSource = source;\n    program = compiler.compile(programSource, options);\n    return program;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "demo": {
      "path": "demo",
      "content": "(function() {\n\n\n}).call(this);\n",
      "type": "blob"
    },
    "haml-jr": {
      "path": "haml-jr",
      "content": "(function() {\n  var compile, extend, lexer, oldParse, parser,\n    __slice = [].slice;\n\n  compile = require(\"./compiler\").compile;\n\n  lexer = require(\"./lib/lexer\").lexer;\n\n  parser = require(\"./lib/parser\").parser;\n\n  extend = function() {\n    var name, source, sources, target, _i, _len;\n    target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    for (_i = 0, _len = sources.length; _i < _len; _i++) {\n      source = sources[_i];\n      for (name in source) {\n        target[name] = source[name];\n      }\n    }\n    return target;\n  };\n\n  oldParse = parser.parse;\n\n  extend(parser, {\n    lexer: lexer,\n    parse: function(input) {\n      extend(parser.yy, {\n        indent: 0,\n        nodePath: [\n          {\n            children: []\n          }\n        ],\n        filterIndent: void 0\n      });\n      return oldParse.call(parser, input);\n    }\n  });\n\n  extend(parser.yy, {\n    extend: extend,\n    newline: function() {\n      var lastNode;\n      lastNode = this.nodePath[this.nodePath.length - 1];\n      if (lastNode.filter) {\n        return this.appendFilterContent(lastNode, \"\");\n      }\n    },\n    append: function(node, indentation) {\n      var index, lastNode, parent;\n      if (indentation == null) {\n        indentation = 0;\n      }\n      if (node.filterLine) {\n        lastNode = this.nodePath[this.nodePath.length - 1];\n        this.appendFilterContent(lastNode, node.filterLine);\n        return;\n      }\n      parent = this.nodePath[indentation];\n      this.appendChild(parent, node);\n      index = indentation + 1;\n      this.nodePath[index] = node;\n      this.nodePath.length = index + 1;\n      return node;\n    },\n    appendChild: function(parent, child) {\n      if (!child.filter) {\n        this.filterIndent = void 0;\n        this.lexer.popState();\n      }\n      parent.children || (parent.children = []);\n      return parent.children.push(child);\n    },\n    appendFilterContent: function(filter, content) {\n      filter.content || (filter.content = \"\");\n      return filter.content += \"\" + content + \"\\n\";\n    }\n  });\n\n  extend(exports, {\n    compile: function(input, options) {\n      if (typeof input === \"string\") {\n        input = parser.parse(input + \"\\n\");\n      }\n      return compile(input, options);\n    },\n    parser: parser\n  });\n\n}).call(this);\n",
      "type": "blob"
    },
    "interactive": {
      "path": "interactive",
      "content": "(function() {\n  var HamlJr;\n\n  HamlJr = require(\"./haml-jr\");\n\n  global.Observable = require(\"observable\");\n\n  global.Runtime = require(\"./runtime\");\n\n  Interactive.register(\"demo\", function(_arg) {\n    var code, model, runtimeElement, source, template, view, _ref;\n    source = _arg.source, runtimeElement = _arg.runtimeElement;\n    code = \"var template, model;\" + CoffeeScript.compile(source, {\n      bare: true\n    });\n    code += \"\\nreturn [template, model];\";\n    _ref = Function(\"Observable\", code)(Observable), template = _ref[0], model = _ref[1];\n    view = Function(\"return \" + HamlJr.compile(template))();\n    return runtimeElement.empty().append(view(model));\n  });\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/lexer": {
      "path": "lib/lexer",
      "content": "var lexer=function(){var lexer={EOF:1,parseError:function parseError(str,hash){if(this.yy.parser){this.yy.parser.parseError(str,hash)}else{throw new Error(str)}},setInput:function(input){this._input=input;this._more=this._backtrack=this.done=false;this.yylineno=this.yyleng=0;this.yytext=this.matched=this.match=\"\";this.conditionStack=[\"INITIAL\"];this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0};if(this.options.ranges){this.yylloc.range=[0,0]}this.offset=0;return this},input:function(){var ch=this._input[0];this.yytext+=ch;this.yyleng++;this.offset++;this.match+=ch;this.matched+=ch;var lines=ch.match(/(?:\\r\\n?|\\n).*/g);if(lines){this.yylineno++;this.yylloc.last_line++}else{this.yylloc.last_column++}if(this.options.ranges){this.yylloc.range[1]++}this._input=this._input.slice(1);return ch},unput:function(ch){var len=ch.length;var lines=ch.split(/(?:\\r\\n?|\\n)/g);this._input=ch+this._input;this.yytext=this.yytext.substr(0,this.yytext.length-len-1);this.offset-=len;var oldLines=this.match.split(/(?:\\r\\n?|\\n)/g);this.match=this.match.substr(0,this.match.length-1);this.matched=this.matched.substr(0,this.matched.length-1);if(lines.length-1){this.yylineno-=lines.length-1}var r=this.yylloc.range;this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:lines?(lines.length===oldLines.length?this.yylloc.first_column:0)+oldLines[oldLines.length-lines.length].length-lines[0].length:this.yylloc.first_column-len};if(this.options.ranges){this.yylloc.range=[r[0],r[0]+this.yyleng-len]}this.yyleng=this.yytext.length;return this},more:function(){this._more=true;return this},reject:function(){if(this.options.backtrack_lexer){this._backtrack=true}else{return this.parseError(\"Lexical error on line \"+(this.yylineno+1)+\". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\"+this.showPosition(),{text:\"\",token:null,line:this.yylineno})}return this},less:function(n){this.unput(this.match.slice(n))},pastInput:function(){var past=this.matched.substr(0,this.matched.length-this.match.length);return(past.length>20?\"...\":\"\")+past.substr(-20).replace(/\\n/g,\"\")},upcomingInput:function(){var next=this.match;if(next.length<20){next+=this._input.substr(0,20-next.length)}return(next.substr(0,20)+(next.length>20?\"...\":\"\")).replace(/\\n/g,\"\")},showPosition:function(){var pre=this.pastInput();var c=new Array(pre.length+1).join(\"-\");return pre+this.upcomingInput()+\"\\n\"+c+\"^\"},test_match:function(match,indexed_rule){var token,lines,backup;if(this.options.backtrack_lexer){backup={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done};if(this.options.ranges){backup.yylloc.range=this.yylloc.range.slice(0)}}lines=match[0].match(/(?:\\r\\n?|\\n).*/g);if(lines){this.yylineno+=lines.length}this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:lines?lines[lines.length-1].length-lines[lines.length-1].match(/\\r?\\n?/)[0].length:this.yylloc.last_column+match[0].length};this.yytext+=match[0];this.match+=match[0];this.matches=match;this.yyleng=this.yytext.length;if(this.options.ranges){this.yylloc.range=[this.offset,this.offset+=this.yyleng]}this._more=false;this._backtrack=false;this._input=this._input.slice(match[0].length);this.matched+=match[0];token=this.performAction.call(this,this.yy,this,indexed_rule,this.conditionStack[this.conditionStack.length-1]);if(this.done&&this._input){this.done=false}if(token){return token}else if(this._backtrack){for(var k in backup){this[k]=backup[k]}return false}return false},next:function(){if(this.done){return this.EOF}if(!this._input){this.done=true}var token,match,tempMatch,index;if(!this._more){this.yytext=\"\";this.match=\"\"}var rules=this._currentRules();for(var i=0;i<rules.length;i++){tempMatch=this._input.match(this.rules[rules[i]]);if(tempMatch&&(!match||tempMatch[0].length>match[0].length)){match=tempMatch;index=i;if(this.options.backtrack_lexer){token=this.test_match(tempMatch,rules[i]);if(token!==false){return token}else if(this._backtrack){match=false;continue}else{return false}}else if(!this.options.flex){break}}}if(match){token=this.test_match(match,rules[index]);if(token!==false){return token}return false}if(this._input===\"\"){return this.EOF}else{return this.parseError(\"Lexical error on line \"+(this.yylineno+1)+\". Unrecognized text.\\n\"+this.showPosition(),{text:\"\",token:null,line:this.yylineno})}},lex:function lex(){var r=this.next();if(r){return r}else{return this.lex()}},begin:function begin(condition){this.conditionStack.push(condition)},popState:function popState(){var n=this.conditionStack.length-1;if(n>0){return this.conditionStack.pop()}else{return this.conditionStack[0]}},_currentRules:function _currentRules(){if(this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]){return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules}else{return this.conditions[\"INITIAL\"].rules}},topState:function topState(n){n=this.conditionStack.length-1-Math.abs(n||0);if(n>=0){return this.conditionStack[n]}else{return\"INITIAL\"}},pushState:function pushState(condition){this.begin(condition)},stateStackSize:function stateStackSize(){return this.conditionStack.length},options:{moduleName:\"lexer\"},performAction:function anonymous(yy,yy_,$avoiding_name_collisions,YY_START){var YYSTATE=YY_START;switch($avoiding_name_collisions){case 0:this.popState();return\"RIGHT_BRACE\";break;case 1:yy_.yytext=yy_.yytext.substring(1);return\"ATTRIBUTE\";break;case 2:this.begin(\"brace_value\");return\"EQUAL\";break;case 3:return\"SEPARATOR\";break;case 4:return\"TEXT\";break;case 5:this.popState();return\"ATTRIBUTE_VALUE\";break;case 6:this.popState();return\"ATTRIBUTE_VALUE\";break;case 7:return\"SEPARATOR\";break;case 8:this.popState();return\"RIGHT_PARENTHESIS\";break;case 9:return\"ATTRIBUTE\";break;case 10:this.begin(\"value\");return\"EQUAL\";break;case 11:this.popState();return\"ATTRIBUTE_VALUE\";break;case 12:this.popState();return\"ATTRIBUTE_VALUE\";break;case 13:this.popState();return\"ATTRIBUTE_VALUE\";break;case 14:yy.indent=0;this.popState();return\"NEWLINE\";break;case 15:return\"FILTER_LINE\";break;case 16:yy.indent=0;return\"NEWLINE\";break;case 17:yy.indent+=1;if(yy.indent>yy.filterIndent){this.begin(\"filter\")};return\"INDENT\";break;case 18:this.begin(\"parentheses_attributes\");return\"LEFT_PARENTHESIS\";break;case 19:this.begin(\"brace_attributes\");return\"LEFT_BRACE\";break;case 20:yy_.yytext=yy_.yytext.substring(1);return\"COMMENT\";break;case 21:yy.filterIndent=yy.indent;yy_.yytext=yy_.yytext.substring(1);return\"FILTER\";break;case 22:yy_.yytext=yy_.yytext.substring(1);return\"ID\";break;case 23:yy_.yytext=yy_.yytext.substring(1);return\"CLASS\";break;case 24:yy_.yytext=yy_.yytext.substring(1);return\"TAG\";break;case 25:yy_.yytext=yy_.yytext.substring(1).trim();return\"BUFFERED_CODE\";break;case 26:yy_.yytext=yy_.yytext.substring(1).trim();return\"UNBUFFERED_CODE\";break;case 27:yy_.yytext=yy_.yytext.trimLeft();return\"TEXT\";break}},rules:[/^(?:\\})/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:[ \\t]*=>[ \\t])/,/^(?:,[ \\t]*)/,/^(?:[^\\}]*)/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:[^ \\t\\}]*)/,/^(?:[ \\t]+)/,/^(?:\\))/,/^(?:([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:=)/,/^(?:\"(\\\\.|[^\\\\\"])*\")/,/^(?:'(\\\\.|[^\\\\'])*')/,/^(?:[^ \\t\\)]*)/,/^(?:(\\n|$))/,/^(?:[^\\n]*)/,/^(?:\\s*(\\n|$))/,/^(?:  )/,/^(?:\\()/,/^(?:\\{)/,/^(?:\\/.*)/,/^(?::([_a-zA-Z][-_a-zA-Z0-9]*))/,/^(?:#((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:\\.((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:%((:|[A-Z]|_|[a-z])((:|[A-Z]|_|[a-z])|-|[0-9])*(?!-)))/,/^(?:=.*)/,/^(?:-.*)/,/^(?:.*)/],conditions:{filter:{rules:[14,15],inclusive:false},value:{rules:[11,12,13],inclusive:false},parentheses_attributes:{rules:[7,8,9,10],inclusive:false},brace_value:{rules:[5,6],inclusive:false},brace_attributes:{rules:[0,1,2,3,4],inclusive:false},INITIAL:{rules:[16,17,18,19,20,21,22,23,24,25,26,27],inclusive:true}}};return lexer}();exports.lexer=lexer;",
      "type": "blob"
    },
    "lib/parser": {
      "path": "lib/parser",
      "content": "var parser=function(){var parser={trace:function trace(){},yy:{},symbols_:{error:2,root:3,lines:4,line:5,indentation:6,indentationLevel:7,INDENT:8,lineMain:9,end:10,tag:11,rest:12,COMMENT:13,FILTER:14,FILTER_LINE:15,NEWLINE:16,name:17,tagComponents:18,attributes:19,idComponent:20,classComponents:21,ID:22,CLASS:23,LEFT_PARENTHESIS:24,attributePairs:25,RIGHT_PARENTHESIS:26,LEFT_BRACE:27,RIGHT_BRACE:28,SEPARATOR:29,attributePair:30,ATTRIBUTE:31,EQUAL:32,ATTRIBUTE_VALUE:33,TAG:34,BUFFERED_CODE:35,UNBUFFERED_CODE:36,TEXT:37,$accept:0,$end:1},terminals_:{2:\"error\",8:\"INDENT\",13:\"COMMENT\",14:\"FILTER\",15:\"FILTER_LINE\",16:\"NEWLINE\",22:\"ID\",23:\"CLASS\",24:\"LEFT_PARENTHESIS\",26:\"RIGHT_PARENTHESIS\",27:\"LEFT_BRACE\",28:\"RIGHT_BRACE\",29:\"SEPARATOR\",31:\"ATTRIBUTE\",32:\"EQUAL\",33:\"ATTRIBUTE_VALUE\",34:\"TAG\",35:\"BUFFERED_CODE\",36:\"UNBUFFERED_CODE\",37:\"TEXT\"},productions_:[0,[3,1],[4,2],[4,1],[6,0],[6,1],[7,2],[7,1],[5,3],[5,1],[9,2],[9,1],[9,1],[9,1],[9,1],[9,1],[10,1],[11,2],[11,2],[11,1],[11,1],[18,3],[18,2],[18,2],[18,2],[18,1],[18,1],[20,1],[21,2],[21,1],[19,3],[19,3],[25,3],[25,1],[30,3],[17,1],[12,1],[12,1],[12,1]],performAction:function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$){var $0=$$.length-1;switch(yystate){case 1:return this.$=yy.nodePath[0].children;break;case 2:this.$=$$[$0-1];break;case 3:this.$=$$[$0];break;case 4:this.$=0;break;case 5:this.$=$$[$0];break;case 6:this.$=$$[$0-1]+1;break;case 7:this.$=1;break;case 8:this.$=yy.append($$[$0-1],$$[$0-2]);break;case 9:this.$=function(){if($$[$0].newline){return yy.newline()}}();break;case 10:this.$=yy.extend($$[$0-1],$$[$0]);break;case 11:this.$=$$[$0];break;case 12:this.$=$$[$0];break;case 13:this.$={comment:$$[$0]};break;case 14:this.$={filter:$$[$0]};break;case 15:this.$={filterLine:$$[$0]};break;case 16:this.$={newline:true};break;case 17:this.$=function(){$$[$0].tag=$$[$0-1];return $$[$0]}();break;case 18:this.$={tag:$$[$0-1],attributes:$$[$0]};break;case 19:this.$={tag:$$[$0]};break;case 20:this.$=yy.extend($$[$0],{tag:\"div\"});break;case 21:this.$={id:$$[$0-2],classes:$$[$0-1],attributes:$$[$0]};break;case 22:this.$={id:$$[$0-1],attributes:$$[$0]};break;case 23:this.$={classes:$$[$0-1],attributes:$$[$0]};break;case 24:this.$={id:$$[$0-1],classes:$$[$0]};break;case 25:this.$={id:$$[$0]};break;case 26:this.$={classes:$$[$0]};break;case 27:this.$=$$[$0];break;case 28:this.$=$$[$0-1].concat($$[$0]);break;case 29:this.$=[$$[$0]];break;case 30:this.$=$$[$0-1];break;case 31:this.$=$$[$0-1];break;case 32:this.$=$$[$0-2].concat($$[$0]);break;case 33:this.$=[$$[$0]];break;case 34:this.$={name:$$[$0-2],value:$$[$0]};break;case 35:this.$=$$[$0];break;case 36:this.$={bufferedCode:$$[$0]};break;case 37:this.$={unbufferedCode:$$[$0]};break;case 38:this.$={text:$$[$0]+\"\\n\"};break}},table:[{3:1,4:2,5:3,6:4,7:6,8:[1,8],10:5,13:[2,4],14:[2,4],15:[2,4],16:[1,7],22:[2,4],23:[2,4],34:[2,4],35:[2,4],36:[2,4],37:[2,4]},{1:[3]},{1:[2,1],5:9,6:4,7:6,8:[1,8],10:5,13:[2,4],14:[2,4],15:[2,4],16:[1,7],22:[2,4],23:[2,4],34:[2,4],35:[2,4],36:[2,4],37:[2,4]},{1:[2,3],8:[2,3],13:[2,3],14:[2,3],15:[2,3],16:[2,3],22:[2,3],23:[2,3],34:[2,3],35:[2,3],36:[2,3],37:[2,3]},{9:10,11:11,12:12,13:[1,13],14:[1,14],15:[1,15],17:16,18:17,20:22,21:23,22:[1,24],23:[1,25],34:[1,21],35:[1,18],36:[1,19],37:[1,20]},{1:[2,9],8:[2,9],13:[2,9],14:[2,9],15:[2,9],16:[2,9],22:[2,9],23:[2,9],34:[2,9],35:[2,9],36:[2,9],37:[2,9]},{8:[1,26],13:[2,5],14:[2,5],15:[2,5],22:[2,5],23:[2,5],34:[2,5],35:[2,5],36:[2,5],37:[2,5]},{1:[2,16],8:[2,16],13:[2,16],14:[2,16],15:[2,16],16:[2,16],22:[2,16],23:[2,16],34:[2,16],35:[2,16],36:[2,16],37:[2,16]},{8:[2,7],13:[2,7],14:[2,7],15:[2,7],22:[2,7],23:[2,7],34:[2,7],35:[2,7],36:[2,7],37:[2,7]},{1:[2,2],8:[2,2],13:[2,2],14:[2,2],15:[2,2],16:[2,2],22:[2,2],23:[2,2],34:[2,2],35:[2,2],36:[2,2],37:[2,2]},{10:27,16:[1,7]},{12:28,16:[2,11],35:[1,18],36:[1,19],37:[1,20]},{16:[2,12]},{16:[2,13]},{16:[2,14]},{16:[2,15]},{16:[2,19],18:29,19:30,20:22,21:23,22:[1,24],23:[1,25],24:[1,31],27:[1,32],35:[2,19],36:[2,19],37:[2,19]},{16:[2,20],35:[2,20],36:[2,20],37:[2,20]},{16:[2,36]},{16:[2,37]},{16:[2,38]},{16:[2,35],22:[2,35],23:[2,35],24:[2,35],27:[2,35],35:[2,35],36:[2,35],37:[2,35]},{16:[2,25],19:34,21:33,23:[1,25],24:[1,31],27:[1,32],35:[2,25],36:[2,25],37:[2,25]},{16:[2,26],19:35,23:[1,36],24:[1,31],27:[1,32],35:[2,26],36:[2,26],37:[2,26]},{16:[2,27],23:[2,27],24:[2,27],27:[2,27],35:[2,27],36:[2,27],37:[2,27]},{16:[2,29],23:[2,29],24:[2,29],27:[2,29],35:[2,29],36:[2,29],37:[2,29]},{8:[2,6],13:[2,6],14:[2,6],15:[2,6],22:[2,6],23:[2,6],34:[2,6],35:[2,6],36:[2,6],37:[2,6]},{1:[2,8],8:[2,8],13:[2,8],14:[2,8],15:[2,8],16:[2,8],22:[2,8],23:[2,8],34:[2,8],35:[2,8],36:[2,8],37:[2,8]},{16:[2,10]},{16:[2,17],35:[2,17],36:[2,17],37:[2,17]},{16:[2,18],35:[2,18],36:[2,18],37:[2,18]},{25:37,30:38,31:[1,39]},{25:40,30:38,31:[1,39]},{16:[2,24],19:41,23:[1,36],24:[1,31],27:[1,32],35:[2,24],36:[2,24],37:[2,24]},{16:[2,22],35:[2,22],36:[2,22],37:[2,22]},{16:[2,23],35:[2,23],36:[2,23],37:[2,23]},{16:[2,28],23:[2,28],24:[2,28],27:[2,28],35:[2,28],36:[2,28],37:[2,28]},{26:[1,42],29:[1,43]},{26:[2,33],28:[2,33],29:[2,33]},{32:[1,44]},{28:[1,45],29:[1,43]},{16:[2,21],35:[2,21],36:[2,21],37:[2,21]},{16:[2,30],35:[2,30],36:[2,30],37:[2,30]},{30:46,31:[1,39]},{33:[1,47]},{16:[2,31],35:[2,31],36:[2,31],37:[2,31]},{26:[2,32],28:[2,32],29:[2,32]},{26:[2,34],28:[2,34],29:[2,34]}],defaultActions:{12:[2,12],13:[2,13],14:[2,14],15:[2,15],18:[2,36],19:[2,37],20:[2,38],28:[2,10]},parseError:function parseError(str,hash){if(hash.recoverable){this.trace(str)}else{throw new Error(str)}},parse:function parse(input){var self=this,stack=[0],vstack=[null],lstack=[],table=this.table,yytext=\"\",yylineno=0,yyleng=0,recovering=0,TERROR=2,EOF=1;this.lexer.setInput(input);this.lexer.yy=this.yy;this.yy.lexer=this.lexer;this.yy.parser=this;if(typeof this.lexer.yylloc==\"undefined\"){this.lexer.yylloc={}}var yyloc=this.lexer.yylloc;lstack.push(yyloc);var ranges=this.lexer.options&&this.lexer.options.ranges;if(typeof this.yy.parseError===\"function\"){this.parseError=this.yy.parseError}else{this.parseError=Object.getPrototypeOf(this).parseError}function popStack(n){stack.length=stack.length-2*n;vstack.length=vstack.length-n;lstack.length=lstack.length-n}function lex(){var token;token=self.lexer.lex()||EOF;if(typeof token!==\"number\"){token=self.symbols_[token]||token}return token}var symbol,preErrorSymbol,state,action,a,r,yyval={},p,len,newState,expected;while(true){state=stack[stack.length-1];if(this.defaultActions[state]){action=this.defaultActions[state]}else{if(symbol===null||typeof symbol==\"undefined\"){symbol=lex()}action=table[state]&&table[state][symbol]}if(typeof action===\"undefined\"||!action.length||!action[0]){var errStr=\"\";expected=[];for(p in table[state]){if(this.terminals_[p]&&p>TERROR){expected.push(\"'\"+this.terminals_[p]+\"'\")}}if(this.lexer.showPosition){errStr=\"Parse error on line \"+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(\", \")+\", got '\"+(this.terminals_[symbol]||symbol)+\"'\"}else{errStr=\"Parse error on line \"+(yylineno+1)+\": Unexpected \"+(symbol==EOF?\"end of input\":\"'\"+(this.terminals_[symbol]||symbol)+\"'\")}this.parseError(errStr,{text:this.lexer.match,token:this.terminals_[symbol]||symbol,line:this.lexer.yylineno,loc:yyloc,expected:expected})}if(action[0]instanceof Array&&action.length>1){throw new Error(\"Parse Error: multiple actions possible at state: \"+state+\", token: \"+symbol)}switch(action[0]){case 1:stack.push(symbol);vstack.push(this.lexer.yytext);lstack.push(this.lexer.yylloc);stack.push(action[1]);symbol=null;if(!preErrorSymbol){yyleng=this.lexer.yyleng;yytext=this.lexer.yytext;yylineno=this.lexer.yylineno;yyloc=this.lexer.yylloc;if(recovering>0){recovering--}}else{symbol=preErrorSymbol;preErrorSymbol=null}break;case 2:len=this.productions_[action[1]][1];yyval.$=vstack[vstack.length-len];yyval._$={first_line:lstack[lstack.length-(len||1)].first_line,last_line:lstack[lstack.length-1].last_line,first_column:lstack[lstack.length-(len||1)].first_column,last_column:lstack[lstack.length-1].last_column};if(ranges){yyval._$.range=[lstack[lstack.length-(len||1)].range[0],lstack[lstack.length-1].range[1]]}r=this.performAction.call(yyval,yytext,yyleng,yylineno,this.yy,action[1],vstack,lstack);if(typeof r!==\"undefined\"){return r}if(len){stack=stack.slice(0,-1*len*2);vstack=vstack.slice(0,-1*len);lstack=lstack.slice(0,-1*len)}stack.push(this.productions_[action[1]][0]);vstack.push(yyval.$);lstack.push(yyval._$);newState=table[stack[stack.length-2]][stack[stack.length-1]];stack.push(newState);break;case 3:return true}}return true}};undefined;function Parser(){this.yy={}}Parser.prototype=parser;parser.Parser=Parser;return new Parser}();if(typeof require!==\"undefined\"&&typeof exports!==\"undefined\"){exports.parser=parser;exports.Parser=parser.Parser;exports.parse=function(){return parser.parse.apply(parser,arguments)};exports.main=function commonjsMain(args){if(!args[1]){console.log(\"Usage: \"+args[0]+\" FILE\");process.exit(1)}var source=require(\"fs\").readFileSync(require(\"path\").normalize(args[1]),\"utf8\");return exports.parser.parse(source)};if(typeof module!==\"undefined\"&&require.main===module){exports.main(process.argv.slice(1))}}",
      "type": "blob"
    },
    "lib/util": {
      "path": "lib/util",
      "content": "(function() {\n  module.exports = {\n    CSON: {\n      parse: function(source) {\n        return Function(\"return \" + (CoffeeScript.compile(source, {\n          bare: true\n        })))();\n      }\n    },\n    applyStylesheet: function(style, id) {\n      var previousStyleNode, styleNode;\n      if (id == null) {\n        id = \"primary\";\n      }\n      styleNode = document.createElement(\"style\");\n      styleNode.innerHTML = style;\n      styleNode.id = id;\n      if (previousStyleNode = document.head.querySelector(\"style#\" + id)) {\n        previousStyleNode.parentNode.removeChild(prevousStyleNode);\n      }\n      return document.head.appendChild(styleNode);\n    }\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "pixie": {
      "path": "pixie",
      "content": "module.exports = {\"version\":\"0.2.2\",\"entryPoint\":\"haml-jr\",\"remoteDependencies\":[\"https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js\"],\"dependencies\":{\"observable\":\"distri/observable:v0.1.2\"}};",
      "type": "blob"
    },
    "runtime": {
      "path": "runtime",
      "content": "(function() {\n  var Observable, Runtime, empty, eventNames, isEvent, isFragment, specialBindings, valueBind,\n    __slice = [].slice;\n\n  Observable = require(\"observable\");\n\n  eventNames = \"abort\\nblur\\nchange\\nclick\\ndblclick\\ndrag\\ndragend\\ndragenter\\ndragleave\\ndragover\\ndragstart\\ndrop\\nerror\\nfocus\\ninput\\nkeydown\\nkeypress\\nkeyup\\nload\\nmousedown\\nmousemove\\nmouseout\\nmouseover\\nmouseup\\nreset\\nresize\\nscroll\\nselect\\nsubmit\\ntouchcancel\\ntouchend\\ntouchenter\\ntouchleave\\ntouchmove\\ntouchstart\\nunload\".split(\"\\n\");\n\n  isEvent = function(name) {\n    return eventNames.indexOf(name) !== -1;\n  };\n\n  isFragment = function(node) {\n    return node.nodeType === 11;\n  };\n\n  valueBind = function(element, value) {\n    var update, updateSelected;\n    value = Observable(value);\n    switch (element.nodeName) {\n      case \"SELECT\":\n        updateSelected = function(newValue) {\n          var options;\n          element._value = newValue;\n          if ((options = element._options) && (typeof newValue === \"object\")) {\n            if (newValue.value != null) {\n              return element.value = newValue.value;\n            } else {\n              return element.selectedIndex = options.indexOf(newValue);\n            }\n          } else {\n            return element.value = newValue;\n          }\n        };\n        setTimeout(function() {\n          return updateSelected(value());\n        }, 0);\n        update = function() {\n          var optionValue, _ref, _value;\n          _ref = this.children[this.selectedIndex], optionValue = _ref.value, _value = _ref._value;\n          return value(_value || optionValue);\n        };\n        element.oninput = element.onchange = update;\n        value.observe(updateSelected);\n        break;\n      default:\n        element.value = value();\n        element.oninput = function() {\n          return value(element.value);\n        };\n        element.onchange = function() {\n          return value(element.value);\n        };\n        value.observe(function(newValue) {\n          return element.value = newValue;\n        });\n    }\n  };\n\n  specialBindings = {\n    SELECT: {\n      options: function(element, values) {\n        var updateValues;\n        values = Observable(values);\n        updateValues = function(values) {\n          empty(element);\n          element._options = values;\n          return values.map(function(value, index) {\n            var option;\n            option = document.createElement(\"option\");\n            option._value = value;\n            if (typeof value === \"object\") {\n              option.value = (value != null ? value.value : void 0) || index;\n            } else {\n              option.value = value;\n            }\n            option.textContent = (value != null ? value.name : void 0) || value;\n            element.appendChild(option);\n            if (value === element._value) {\n              element.selectedIndex = index;\n            }\n            return option;\n          });\n        };\n        updateValues(values());\n        return values.observe(updateValues);\n      }\n    }\n  };\n\n  Runtime = function(context) {\n    var append, bindObservable, classes, id, lastParent, observeAttribute, observeText, pop, push, render, self, stack, top;\n    stack = [];\n    lastParent = function() {\n      var element, i;\n      i = stack.length - 1;\n      while ((element = stack[i]) && isFragment(element)) {\n        i -= 1;\n      }\n      return element;\n    };\n    top = function() {\n      return stack[stack.length - 1];\n    };\n    append = function(child) {\n      var parent, _ref;\n      parent = top();\n      if (parent && isFragment(child) && child.childNodes.length === 1) {\n        child = child.childNodes[0];\n      }\n      if ((_ref = top()) != null) {\n        _ref.appendChild(child);\n      }\n      return child;\n    };\n    push = function(child) {\n      return stack.push(child);\n    };\n    pop = function() {\n      return append(stack.pop());\n    };\n    render = function(child) {\n      push(child);\n      return pop();\n    };\n    bindObservable = function(element, value, update) {\n      var observable, observe, unobserve;\n      observable = Observable(value);\n      update(observable());\n      observe = function() {\n        observable.observe(update);\n        return update(observable());\n      };\n      unobserve = function() {\n        return observable.stopObserving(update);\n      };\n      element.addEventListener(\"DOMNodeInserted\", observe, true);\n      element.addEventListener(\"DOMNodeRemoved\", unobserve, true);\n      return element;\n    };\n    id = function() {\n      var element, sources, update, value;\n      sources = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      element = top();\n      update = function(newValue) {\n        if (typeof newValue === \"function\") {\n          newValue = newValue();\n        }\n        return element.id = newValue;\n      };\n      value = function() {\n        var possibleValues;\n        possibleValues = sources.map(function(source) {\n          if (typeof source === \"function\") {\n            return source();\n          } else {\n            return source;\n          }\n        }).filter(function(idValue) {\n          return idValue != null;\n        });\n        return possibleValues[possibleValues.length - 1];\n      };\n      return bindObservable(element, value, update);\n    };\n    classes = function() {\n      var element, sources, update, value;\n      sources = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      element = top();\n      update = function(newValue) {\n        if (typeof newValue === \"function\") {\n          newValue = newValue();\n        }\n        return element.className = newValue;\n      };\n      value = function() {\n        var possibleValues;\n        possibleValues = sources.map(function(source) {\n          if (typeof source === \"function\") {\n            return source();\n          } else {\n            return source;\n          }\n        }).filter(function(sourceValue) {\n          return sourceValue != null;\n        });\n        return possibleValues.join(\" \");\n      };\n      return bindObservable(element, value, update);\n    };\n    observeAttribute = function(name, value) {\n      var binding, element, nodeName, update, _ref;\n      element = top();\n      nodeName = element.nodeName;\n      update = function(newValue) {\n        if ((newValue != null) && newValue !== false) {\n          return element.setAttribute(name, newValue);\n        } else {\n          return element.removeAttribute(name);\n        }\n      };\n      if ((name === \"value\") && (typeof value === \"function\")) {\n        valueBind(element, value);\n      } else if ((name === \"checked\") && (typeof value === \"function\")) {\n        element.onchange = function() {\n          return value(element.checked);\n        };\n        bindObservable(element, value, update);\n      } else if (binding = (_ref = specialBindings[nodeName]) != null ? _ref[name] : void 0) {\n        binding(element, value);\n      } else if (name.match(/^on/) && isEvent(name.substr(2))) {\n        element[name] = value;\n      } else if (isEvent(name)) {\n        element[\"on\" + name] = value;\n      } else {\n        bindObservable(element, value, update);\n      }\n      return element;\n    };\n    observeText = function(value) {\n      var element, update;\n      switch (value != null ? value.nodeType : void 0) {\n        case 1:\n        case 3:\n        case 11:\n          return render(value);\n      }\n      element = document.createTextNode('');\n      update = function(newValue) {\n        return element.nodeValue = newValue;\n      };\n      bindObservable(element, value, update);\n      return render(element);\n    };\n    self = {\n      push: push,\n      pop: pop,\n      id: id,\n      classes: classes,\n      attribute: observeAttribute,\n      text: observeText,\n      filter: function(name, content) {},\n      each: function(items, fn) {\n        var elements, parent, replace;\n        items = Observable(items);\n        elements = null;\n        parent = lastParent();\n        items.observe(function() {\n          return replace(elements);\n        });\n        replace = function(oldElements) {\n          elements = [];\n          items.each(function(item, index, array) {\n            var element;\n            element = fn.call(item, item, index, array);\n            if (isFragment(element)) {\n              elements.push.apply(elements, element.childNodes);\n            } else {\n              elements.push(element);\n            }\n            parent.appendChild(element);\n            return element;\n          });\n          return oldElements != null ? oldElements.forEach(function(element) {\n            return element.remove();\n          }) : void 0;\n        };\n        return replace(null, items);\n      }\n    };\n    return self;\n  };\n\n  module.exports = Runtime;\n\n  empty = function(node) {\n    var child, _results;\n    _results = [];\n    while (child = node.firstChild) {\n      _results.push(node.removeChild(child));\n    }\n    return _results;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "style/demo": {
      "path": "style/demo",
      "content": "module.exports = \"#container  .sections  textarea {\\n  width: 50%;\\n}\";",
      "type": "blob"
    },
    "test/haml-jr": {
      "path": "test/haml-jr",
      "content": "(function() {\n  var HamlJr, Runtime, compile, makeTemplate, parser, run, _ref;\n\n  _ref = HamlJr = require(\"/haml-jr\"), parser = _ref.parser, compile = _ref.compile;\n\n  Runtime = require(\"/runtime\");\n\n  global.Observable = require(\"observable\");\n\n  makeTemplate = function(code) {\n    var compiled;\n    compiled = compile(code);\n    return Function(\"Runtime\", \"return \" + compiled)(Runtime);\n  };\n\n  run = function(code, data) {\n    return makeTemplate(code)(data);\n  };\n\n  describe('HamlJr', function() {\n    describe('parser', function() {\n      it('should exist', function() {\n        return assert(parser);\n      });\n      return it('should parse some stuff', function() {\n        return assert(parser.parse(\"%yolo\"));\n      });\n    });\n    describe('compiler', function() {\n      return describe('keywords', function() {\n        it(\"should not replace `items.each` with `items.__each`\", function() {\n          var compiled;\n          compiled = compile('- items.each ->');\n          return assert(!compiled.match(/items.__each/));\n        });\n        return it(\"should replace `on 'click'` with `__runtime.on 'click'`\", function() {\n          var compiled;\n          compiled = compile('- on \"click\", ->');\n          return assert(compiled.match(/__runtime.on\\(\"click\"/));\n        });\n      });\n    });\n    describe(\"runtime\", function() {\n      return it(\"should not blow up on undefined text node values\", function() {\n        return assert(run('= @notThere'));\n      });\n    });\n    describe(\"classes\", function() {\n      return it(\"should render the classes passed in along with the classes prefixed\", function() {\n        var result;\n        result = run(\".radical(class=@myClass)\", {\n          myClass: \"duder\"\n        });\n        return assert.equal(result.childNodes[0].className, \"radical duder\");\n      });\n    });\n    describe(\"ids\", function() {\n      it(\"should get them from the prefix\", function() {\n        var result;\n        result = run(\"#radical\");\n        return assert.equal(result.childNodes[0].id, \"radical\");\n      });\n      it(\"should be overridden by the attribute value if present\", function() {\n        var result;\n        result = run(\"#radical(id=@id)\", {\n          id: \"wat\"\n        });\n        return assert.equal(result.childNodes[0].id, \"wat\");\n      });\n      return it(\"should not be overridden by the attribute value if not present\", function() {\n        var result;\n        result = run(\"#radical(id=@id)\");\n        return assert.equal(result.childNodes[0].id, \"radical\");\n      });\n    });\n    describe(\"text\", function() {\n      return it(\"should render text in nodes\", function() {\n        var result;\n        result = run(\"%div heyy\");\n        return assert.equal(result.childNodes[0].textContent, \"heyy\\n\");\n      });\n    });\n    return describe(\"each\", function() {\n      return it(\"should subrender\", function() {\n        var code, result;\n        global.testTemplate = makeTemplate(\".test= @\");\n        code = \"%div\\n  - each @, (item) ->\\n    = testTemplate item\";\n        result = run(code, [0, 1, 2, 3]);\n        return assert.equal(result.childNodes[0].childNodes[3].textContent, \"3\");\n      });\n    });\n  });\n\n}).call(this);\n",
      "type": "blob"
    },
    "test/samples": {
      "path": "test/samples",
      "content": "(function() {\n  var HamlJr, compile, parser, samples, _ref;\n\n  _ref = HamlJr = require(\"/haml-jr\"), parser = _ref.parser, compile = _ref.compile;\n\n  samples = {\n    attributes: \".yolo(id=@id class=\\\"cool cat\\\" data-test=\\\"test\\\" dude=@test)\\n#test.yolo2(class=@duder)\",\n    browser: \"%html\\n  %head\\n    %script(src=\\\"lib/cornerstone.js\\\")\\n    %script(src=\\\"lib/coffee-script.js\\\")\\n    %script(src=\\\"lib/jquery-1.10.2.min.js\\\")\\n    %script(src=\\\"build/web.js\\\")\\n  %body\\n    %textarea\\n      :verbatim\\n        Choose a ticket class:\\n        %select\\n          - on \\\"change\\\", @chosenTicket\\n          - each @tickets, ->\\n            %option= @name\\n\\n        %button Clear\\n          - on \\\"click\\\", @resetTicket\\n\\n        - with @chosenTicket, ->\\n          %p\\n            - if @price\\n              You have chosen\\n              %b= @name\\n              %span\\n                $\" + this.price + \"\\n            - else\\n              No ticket chosen\\n\",\n    code_following_text: \"Some Text\\n- a = \\\"wat\\\"\",\n    complex: \"%select\\n  - radicalMessage = \\\"Yolo\\\"\\n  - @tickets.forEach (ticket, i) ->\\n    - if i is 0\\n      = radicalMessage\\n    %option\\n      = ticket.name\",\n    complex2: \"!!!\\n%html\\n  %head\\n    %title Ravel | \" + this.name + \"'s photo tagged \" + this.tag + \"\\n\\n    - @props.each (key, value) ->\\n      %meta(property=key content=value)\\n\\n    %link{:href => \\\"/images/favicon.ico\\\", :rel => \\\"icon\\\", :type => \\\"image/x-icon\\\"}\\n\\n    %link(rel=\\\"stylesheet\\\" href=\\\"/stylesheets/normalize.css\\\")\\n    %link(rel=\\\"stylesheet\\\" href=\\\"/stylesheets/bootstrap.min.css\\\")\\n    %link(rel=\\\"stylesheet\\\" href=\\\"/stylesheets/main.css\\\")\\n\\n    %script{:src => \\\"//use.typekit.net/ghp4eka.js\\\"}\\n    :javascript\\n      try{Typekit.load();}catch(e){}\\n\\n  %body\\n    .facebook\\n      %header\\n        %h1.hide-text\\n          Ravel\\n      .content\\n        .container\\n          .individual\\n            .user-container.clearfix\\n              .left\\n                .user-image\\n                  %img{:src => @profile_picture_url}\\n                .user-info\\n                  %span.name= @name\\n                  %span.info= @gender_and_age\\n                  %span.location.info= @location\\n                  %span.tag= @tag\\n              .right\\n                %span.pins\\n                  %img{:src => \\\"/images/pins@2x.png\\\"}\\n                  = @pins\\n                %span.likes\\n                  %img{:src => \\\"/images/likes@2x.png\\\"}\\n                  = @likes\\n            .photo-container\\n              %img{:src => @photo_url}\\n          .download-button\\n            %a.button.appstore{:href => \\\"http://itunes.apple.com/us/app/ravel!/id610859881?ls=1&mt=8\\\"}\",\n    empty_lines: \"%li\\n\\n  %ul\\n\\n    Yo\\n\\n\\n\\n\\n\",\n    filters: \":plain\\n  cool\\n  super cool\\n    double super cool\",\n    filters2: \"\\n\\n:javascript\\n  alert('yolo');\\n\\n:coffeescript\\n  alert \\\"yolo\\\"\\n\\n.duder\\n  col\\n\\n  :plain\\n    sweets\\n\\n.duder2\\n  cool\\n\",\n    literal: \"<literal>\\n  <wat>\\n  </wat>\\n</literal>\\n<yolo></yolo>\",\n    simple: \"%section#main.container\\n  - post = title: \\\"cool\\\", subtitle: \\\"yolo\\\", content: \\\"radical\\\"\\n  %h1= post.title\\n  %h2= post.subtitle\\n  .content\\n    = post.content\",\n    single_quotes: \"%img(src='http://duderman.info/\\#{yolocountyusa}' data-rad='what the duder?')\",\n    tickets: \"Choose a ticket class:\\n%select\\n  - on \\\"change\\\", @chosenTicket\\n  - each @tickets, ->\\n    %option= @name\\n\\n%button Clear\\n  - on \\\"click\\\", @resetTicket\\n\\n- with @chosenTicket, ->\\n  %p\\n    - if @price\\n      You have chosen\\n      %b= @name\\n      %span\\n        $\" + this.price + \"\\n    - else\\n      No ticket chosen\"\n  };\n\n  describe(\"Samples\", function() {\n    return Object.keys(samples).forEach(function(name) {\n      var data;\n      data = samples[name];\n      it(\"should parse '\" + name + \"'\", function() {\n        var result;\n        result = parser.parse(data);\n        console.log(result);\n        return assert(result);\n      });\n      return it(\"should compile \" + name, function() {\n        var result;\n        result = compile(data);\n        console.log(result);\n        return assert(result);\n      });\n    });\n  });\n\n}).call(this);\n",
      "type": "blob"
    }
  },
  "progenitor": {
    "url": "http://www.danielx.net/editor/"
  },
  "version": "0.2.2",
  "entryPoint": "haml-jr",
  "remoteDependencies": [
    "https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"
  ],
  "repository": {
    "branch": "touch-up-select",
    "default_branch": "master",
    "full_name": "distri/haml-jr",
    "homepage": null,
    "description": "Haml reborn. Pure HTML5 templating.",
    "html_url": "https://github.com/distri/haml-jr",
    "url": "https://api.github.com/repos/distri/haml-jr",
    "publishBranch": "gh-pages"
  },
  "dependencies": {
    "observable": {
      "source": {
        "LICENSE": {
          "path": "LICENSE",
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 distri\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
          "mode": "100644",
          "type": "blob"
        },
        "README.md": {
          "path": "README.md",
          "content": "observable\n==========\n",
          "mode": "100644",
          "type": "blob"
        },
        "main.coffee.md": {
          "path": "main.coffee.md",
          "content": "Observable\n==========\n\n`Observable` allows for observing arrays, functions, and objects.\n\nFunction dependencies are automagically observed.\n\nStandard array methods are proxied through to the underlying array.\n\n    Observable = (value) ->\n\nReturn the object if it is already an observable object.\n\n      return value if typeof value?.observe is \"function\"\n\nMaintain a set of listeners to observe changes and provide a helper to notify each observer.\n\n      listeners = []\n\n      notify = (newValue) ->\n        listeners.forEach (listener) ->\n          listener(newValue)\n\nOur observable function is stored as a reference to `self`.\n\nIf `value` is a function compute dependencies and listen to observables that it depends on.\n\n      if typeof value is 'function'\n        fn = value\n        self = ->\n          # Automagic dependency observation\n          magicDependency(self)\n\n          return value\n\n        self.observe = (listener) ->\n          listeners.push listener\n\n        changed = ->\n          value = fn()\n          notify(value)\n\n        value = computeDependencies(fn, changed)\n\n      else\n\nWhen called with zero arguments it is treated as a getter. When called with one argument it is treated as a setter.\n\nChanges to the value will trigger notifications.\n\nThe value is always returned.\n\n        self = (newValue) ->\n          if arguments.length > 0\n            if value != newValue\n              value = newValue\n\n              notify(newValue)\n          else\n            # Automagic dependency observation\n            magicDependency(self)\n\n          return value\n\nAdd a listener for when this object changes.\n\n        self.observe = (listener) ->\n          listeners.push listener\n\nThis `each` iterator is similar to [the Maybe monad](http://en.wikipedia.org/wiki/Monad_&#40;functional_programming&#41;#The_Maybe_monad) in that our observable may contain a single value or nothing at all.\n\n      self.each = (args...) ->\n        if value?\n          [value].forEach(args...)\n\nIf the value is an array then proxy array methods and add notifications to mutation events.\n\n      if Array.isArray(value)\n        [\n          \"concat\"\n          \"every\"\n          \"filter\"\n          \"forEach\"\n          \"indexOf\"\n          \"join\"\n          \"lastIndexOf\"\n          \"map\"\n          \"reduce\"\n          \"reduceRight\"\n          \"slice\"\n          \"some\"\n        ].forEach (method) ->\n          self[method] = (args...) ->\n            value[method](args...)\n\n        [\n          \"pop\"\n          \"push\"\n          \"reverse\"\n          \"shift\"\n          \"splice\"\n          \"sort\"\n          \"unshift\"\n        ].forEach (method) ->\n          self[method] = (args...) ->\n            notifyReturning value[method](args...)\n\n        notifyReturning = (returnValue) ->\n          notify(value)\n\n          return returnValue\n\nAdd some extra helpful methods to array observables.\n\n        extend self,\n          each: (args...) ->\n            self.forEach(args...)\n\n            return self\n\nRemove an element from the array and notify observers of changes.\n\n          remove: (object) ->\n            index = value.indexOf(object)\n\n            if index >= 0\n              notifyReturning value.splice(index, 1)[0]\n\n          get: (index) ->\n            value[index]\n\n          first: ->\n            value[0]\n\n          last: ->\n            value[value.length-1]\n\n      extend self,\n        stopObserving: (fn) ->\n          remove listeners, fn\n\n        toggle: ->\n          self !value\n\n        increment: (n) ->\n          self value + n\n\n        decrement: (n) ->\n          self value - n\n\n        toString: ->\n          \"Observable(#{value})\"\n\n      return self\n\nExport `Observable`\n\n    module.exports = Observable\n\nAppendix\n--------\n\nThe extend method adds one objects properties to another.\n\n    extend = (target, sources...) ->\n      for source in sources\n        for name of source\n          target[name] = source[name]\n\n      return target\n\nSuper hax for computing dependencies. This needs to be a shared global so that\ndifferent bundled versions of observable libraries can interoperate.\n\n    global.OBSERVABLE_ROOT_HACK = undefined\n\n    magicDependency = (self) ->\n      if base = global.OBSERVABLE_ROOT_HACK\n        self.observe base\n\n    withBase = (root, fn) ->\n      global.OBSERVABLE_ROOT_HACK = root\n      value = fn()\n      global.OBSERVABLE_ROOT_HACK = undefined\n\n      return value\n\n    base = ->\n      global.OBSERVABLE_ROOT_HACK\n\nAutomagically compute dependencies.\n\n    computeDependencies = (fn, root) ->\n      withBase root, ->\n        fn()\n\nRemove a value from an array.\n\n    remove = (array, value) ->\n      index = array.indexOf(value)\n\n      if index >= 0\n        array.splice(index, 1)[0]\n",
          "mode": "100644",
          "type": "blob"
        },
        "pixie.cson": {
          "path": "pixie.cson",
          "content": "version: \"0.1.2\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/observable.coffee": {
          "path": "test/observable.coffee",
          "content": "global.Observable = require \"../main\"\n\ndescribe 'Observable', ->\n  it 'should create an observable for an object', ->\n    n = 5\n\n    observable = Observable(n)\n\n    assert.equal(observable(), n)\n\n  it 'should fire events when setting', ->\n    string = \"yolo\"\n\n    observable = Observable(string)\n    observable.observe (newValue) ->\n      assert.equal newValue, \"4life\"\n\n    observable(\"4life\")\n\n  it 'should be idempotent', ->\n    o = Observable(5)\n\n    assert.equal o, Observable(o)\n\n  describe \"#each\", ->\n    it \"should be invoked once if there is an observable\", ->\n      o = Observable(5)\n      called = 0\n\n      o.each (value) ->\n        called += 1\n        assert.equal value, 5\n\n      assert.equal called, 1\n\n    it \"should not be invoked if observable is null\", ->\n      o = Observable(null)\n      called = 0\n\n      o.each (value) ->\n        called += 1\n\n      assert.equal called, 0\n\n  it \"should allow for stopping observation\", ->\n    observable = Observable(\"string\")\n\n    called = 0\n    fn = (newValue) ->\n      called += 1\n      assert.equal newValue, \"4life\"\n\n    observable.observe fn\n\n    observable(\"4life\")\n\n    observable.stopObserving fn\n\n    observable(\"wat\")\n\n    assert.equal called, 1\n\n  it \"should increment\", ->\n    observable = Observable 1\n\n    observable.increment(5)\n\n    assert.equal observable(), 6\n\n  it \"should decremnet\", ->\n    observable = Observable 1\n\n    observable.decrement 5\n\n    assert.equal observable(), -4\n\n  it \"should toggle\", ->\n    observable = Observable false\n\n    observable.toggle()\n    assert.equal observable(), true\n\n    observable.toggle()\n    assert.equal observable(), false\n\ndescribe \"Observable Array\", ->\n  it \"should proxy array methods\", ->\n    o = Observable [5]\n\n    o.map (n) ->\n      assert.equal n, 5\n\n  it \"should notify on mutation methods\", (done) ->\n    o = Observable []\n\n    o.observe (newValue) ->\n      assert.equal newValue[0], 1\n\n    o.push 1\n\n    done()\n\n  it \"should have an each method\", ->\n    o = Observable []\n\n    assert o.each\n\n  it \"#get\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.get(2), 2\n\n  it \"#first\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.first(), 0\n\n  it \"#last\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.last(), 3\n\n  it \"#remove\", (done) ->\n    o = Observable [0, 1, 2, 3]\n\n    o.observe (newValue) ->\n      assert.equal newValue.length, 3\n      setTimeout ->\n        done()\n      , 0\n\n    assert.equal o.remove(2), 2\n\n  # TODO: This looks like it might be impossible\n  it \"should proxy the length property\"\n\ndescribe \"Observable functions\", ->\n  it \"should compute dependencies\", (done) ->\n    firstName = Observable \"Duder\"\n    lastName = Observable \"Man\"\n\n    o = Observable ->\n      \"#{firstName()} #{lastName()}\"\n\n    o.observe (newValue) ->\n      assert.equal newValue, \"Duder Bro\"\n\n      done()\n\n    lastName \"Bro\"\n\n  it \"should allow double nesting\", (done) ->\n    bottom = Observable \"rad\"\n    middle = Observable ->\n      bottom()\n    top = Observable ->\n      middle()\n\n    top.observe (newValue) ->\n      assert.equal newValue, \"wat\"\n      assert.equal top(), newValue\n      assert.equal middle(), newValue\n\n      done()\n\n    bottom(\"wat\")\n\n  it \"should have an each method\", ->\n    o = Observable ->\n\n    assert o.each\n\n  it \"should not invoke when returning undefined\", ->\n    o = Observable ->\n\n    o.each ->\n      assert false\n\n  it \"should invoke when returning any defined value\", (done) ->\n    o = Observable -> 5\n\n    o.each (n) ->\n      assert.equal n, 5\n      done()\n\n  it \"should work on an array dependency\", ->\n    oA = Observable [1, 2, 3]\n\n    o = Observable ->\n      oA()[0]\n\n    last = Observable ->\n      oA()[oA().length-1]\n\n    assert.equal o(), 1\n\n    oA.unshift 0\n\n    assert.equal o(), 0\n\n    oA.push 4\n\n    assert.equal last(), 4, \"Last should be 4\"\n",
          "mode": "100644",
          "type": "blob"
        }
      },
      "distribution": {
        "main": {
          "path": "main",
          "content": "(function() {\n  var Observable, base, computeDependencies, extend, magicDependency, remove, withBase,\n    __slice = [].slice;\n\n  Observable = function(value) {\n    var changed, fn, listeners, notify, notifyReturning, self;\n    if (typeof (value != null ? value.observe : void 0) === \"function\") {\n      return value;\n    }\n    listeners = [];\n    notify = function(newValue) {\n      return listeners.forEach(function(listener) {\n        return listener(newValue);\n      });\n    };\n    if (typeof value === 'function') {\n      fn = value;\n      self = function() {\n        magicDependency(self);\n        return value;\n      };\n      self.observe = function(listener) {\n        return listeners.push(listener);\n      };\n      changed = function() {\n        value = fn();\n        return notify(value);\n      };\n      value = computeDependencies(fn, changed);\n    } else {\n      self = function(newValue) {\n        if (arguments.length > 0) {\n          if (value !== newValue) {\n            value = newValue;\n            notify(newValue);\n          }\n        } else {\n          magicDependency(self);\n        }\n        return value;\n      };\n      self.observe = function(listener) {\n        return listeners.push(listener);\n      };\n    }\n    self.each = function() {\n      var args, _ref;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (value != null) {\n        return (_ref = [value]).forEach.apply(_ref, args);\n      }\n    };\n    if (Array.isArray(value)) {\n      [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return value[method].apply(value, args);\n        };\n      });\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return notifyReturning(value[method].apply(value, args));\n        };\n      });\n      notifyReturning = function(returnValue) {\n        notify(value);\n        return returnValue;\n      };\n      extend(self, {\n        each: function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          self.forEach.apply(self, args);\n          return self;\n        },\n        remove: function(object) {\n          var index;\n          index = value.indexOf(object);\n          if (index >= 0) {\n            return notifyReturning(value.splice(index, 1)[0]);\n          }\n        },\n        get: function(index) {\n          return value[index];\n        },\n        first: function() {\n          return value[0];\n        },\n        last: function() {\n          return value[value.length - 1];\n        }\n      });\n    }\n    extend(self, {\n      stopObserving: function(fn) {\n        return remove(listeners, fn);\n      },\n      toggle: function() {\n        return self(!value);\n      },\n      increment: function(n) {\n        return self(value + n);\n      },\n      decrement: function(n) {\n        return self(value - n);\n      },\n      toString: function() {\n        return \"Observable(\" + value + \")\";\n      }\n    });\n    return self;\n  };\n\n  module.exports = Observable;\n\n  extend = function() {\n    var name, source, sources, target, _i, _len;\n    target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    for (_i = 0, _len = sources.length; _i < _len; _i++) {\n      source = sources[_i];\n      for (name in source) {\n        target[name] = source[name];\n      }\n    }\n    return target;\n  };\n\n  global.OBSERVABLE_ROOT_HACK = void 0;\n\n  magicDependency = function(self) {\n    var base;\n    if (base = global.OBSERVABLE_ROOT_HACK) {\n      return self.observe(base);\n    }\n  };\n\n  withBase = function(root, fn) {\n    var value;\n    global.OBSERVABLE_ROOT_HACK = root;\n    value = fn();\n    global.OBSERVABLE_ROOT_HACK = void 0;\n    return value;\n  };\n\n  base = function() {\n    return global.OBSERVABLE_ROOT_HACK;\n  };\n\n  computeDependencies = function(fn, root) {\n    return withBase(root, function() {\n      return fn();\n    });\n  };\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "pixie": {
          "path": "pixie",
          "content": "module.exports = {\"version\":\"0.1.2\"};",
          "type": "blob"
        },
        "test/observable": {
          "path": "test/observable",
          "content": "(function() {\n  global.Observable = require(\"../main\");\n\n  describe('Observable', function() {\n    it('should create an observable for an object', function() {\n      var n, observable;\n      n = 5;\n      observable = Observable(n);\n      return assert.equal(observable(), n);\n    });\n    it('should fire events when setting', function() {\n      var observable, string;\n      string = \"yolo\";\n      observable = Observable(string);\n      observable.observe(function(newValue) {\n        return assert.equal(newValue, \"4life\");\n      });\n      return observable(\"4life\");\n    });\n    it('should be idempotent', function() {\n      var o;\n      o = Observable(5);\n      return assert.equal(o, Observable(o));\n    });\n    describe(\"#each\", function() {\n      it(\"should be invoked once if there is an observable\", function() {\n        var called, o;\n        o = Observable(5);\n        called = 0;\n        o.each(function(value) {\n          called += 1;\n          return assert.equal(value, 5);\n        });\n        return assert.equal(called, 1);\n      });\n      return it(\"should not be invoked if observable is null\", function() {\n        var called, o;\n        o = Observable(null);\n        called = 0;\n        o.each(function(value) {\n          return called += 1;\n        });\n        return assert.equal(called, 0);\n      });\n    });\n    it(\"should allow for stopping observation\", function() {\n      var called, fn, observable;\n      observable = Observable(\"string\");\n      called = 0;\n      fn = function(newValue) {\n        called += 1;\n        return assert.equal(newValue, \"4life\");\n      };\n      observable.observe(fn);\n      observable(\"4life\");\n      observable.stopObserving(fn);\n      observable(\"wat\");\n      return assert.equal(called, 1);\n    });\n    it(\"should increment\", function() {\n      var observable;\n      observable = Observable(1);\n      observable.increment(5);\n      return assert.equal(observable(), 6);\n    });\n    it(\"should decremnet\", function() {\n      var observable;\n      observable = Observable(1);\n      observable.decrement(5);\n      return assert.equal(observable(), -4);\n    });\n    return it(\"should toggle\", function() {\n      var observable;\n      observable = Observable(false);\n      observable.toggle();\n      assert.equal(observable(), true);\n      observable.toggle();\n      return assert.equal(observable(), false);\n    });\n  });\n\n  describe(\"Observable Array\", function() {\n    it(\"should proxy array methods\", function() {\n      var o;\n      o = Observable([5]);\n      return o.map(function(n) {\n        return assert.equal(n, 5);\n      });\n    });\n    it(\"should notify on mutation methods\", function(done) {\n      var o;\n      o = Observable([]);\n      o.observe(function(newValue) {\n        return assert.equal(newValue[0], 1);\n      });\n      o.push(1);\n      return done();\n    });\n    it(\"should have an each method\", function() {\n      var o;\n      o = Observable([]);\n      return assert(o.each);\n    });\n    it(\"#get\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.get(2), 2);\n    });\n    it(\"#first\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.first(), 0);\n    });\n    it(\"#last\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.last(), 3);\n    });\n    it(\"#remove\", function(done) {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      o.observe(function(newValue) {\n        assert.equal(newValue.length, 3);\n        return setTimeout(function() {\n          return done();\n        }, 0);\n      });\n      return assert.equal(o.remove(2), 2);\n    });\n    return it(\"should proxy the length property\");\n  });\n\n  describe(\"Observable functions\", function() {\n    it(\"should compute dependencies\", function(done) {\n      var firstName, lastName, o;\n      firstName = Observable(\"Duder\");\n      lastName = Observable(\"Man\");\n      o = Observable(function() {\n        return \"\" + (firstName()) + \" \" + (lastName());\n      });\n      o.observe(function(newValue) {\n        assert.equal(newValue, \"Duder Bro\");\n        return done();\n      });\n      return lastName(\"Bro\");\n    });\n    it(\"should allow double nesting\", function(done) {\n      var bottom, middle, top;\n      bottom = Observable(\"rad\");\n      middle = Observable(function() {\n        return bottom();\n      });\n      top = Observable(function() {\n        return middle();\n      });\n      top.observe(function(newValue) {\n        assert.equal(newValue, \"wat\");\n        assert.equal(top(), newValue);\n        assert.equal(middle(), newValue);\n        return done();\n      });\n      return bottom(\"wat\");\n    });\n    it(\"should have an each method\", function() {\n      var o;\n      o = Observable(function() {});\n      return assert(o.each);\n    });\n    it(\"should not invoke when returning undefined\", function() {\n      var o;\n      o = Observable(function() {});\n      return o.each(function() {\n        return assert(false);\n      });\n    });\n    it(\"should invoke when returning any defined value\", function(done) {\n      var o;\n      o = Observable(function() {\n        return 5;\n      });\n      return o.each(function(n) {\n        assert.equal(n, 5);\n        return done();\n      });\n    });\n    return it(\"should work on an array dependency\", function() {\n      var last, o, oA;\n      oA = Observable([1, 2, 3]);\n      o = Observable(function() {\n        return oA()[0];\n      });\n      last = Observable(function() {\n        return oA()[oA().length - 1];\n      });\n      assert.equal(o(), 1);\n      oA.unshift(0);\n      assert.equal(o(), 0);\n      oA.push(4);\n      return assert.equal(last(), 4, \"Last should be 4\");\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        }
      },
      "progenitor": {
        "url": "http://www.danielx.net/editor/"
      },
      "version": "0.1.2",
      "entryPoint": "main",
      "repository": {
        "branch": "v0.1.2",
        "default_branch": "master",
        "full_name": "distri/observable",
        "homepage": null,
        "description": "",
        "html_url": "https://github.com/distri/observable",
        "url": "https://api.github.com/repos/distri/observable",
        "publishBranch": "gh-pages"
      },
      "dependencies": {}
    }
  }
});